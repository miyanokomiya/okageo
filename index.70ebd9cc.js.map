{"mappings":"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","sources":["demo/main.ts","src/geo.ts","node_modules/@parcel/transformer-js/src/esmodule-helpers.js","src/svg.ts"],"sourcesContent":["import * as geo from '../src/geo'\nimport * as svg from '../src/svg'\n\nconst canvas = document.getElementById('canvas') as HTMLCanvasElement\nconst ctx = canvas.getContext('2d')\nconst fileInput = document.getElementById('input') as HTMLInputElement\nfileInput.onchange = (e) => {\n  const file = (e.target as HTMLInputElement).files\n  if (!file || file.length === 0) return\n\n  const reader = new FileReader()\n  reader.readAsText(file[0])\n  reader.onload = () => {\n    if (!ctx) return\n    ctx.clearRect(0, 0, canvas.width, canvas.height)\n    const pathInfoList = svg.parseSvgGraphicsStr(reader.result as string)\n    const inRectList = svg.fitRect(\n      pathInfoList,\n      0,\n      0,\n      canvas.width,\n      canvas.height\n    )\n    inRectList.forEach((info) => {\n      geo.triangleSplit(info.d).forEach((points) => {\n        svg.draw(ctx, { d: points, style: info.style })\n      })\n    })\n  }\n}\n\nfunction runReverse() {\n  const text = (document.getElementById('input-path') as HTMLInputElement)!\n    .value\n  ;(document.getElementById('reverse-result') as HTMLInputElement)!.value =\n    svg.pathSegmentRawsToString(svg.reversePath(svg.parsePathSegmentRaws(text)))\n\n  document.getElementById('path-src')!.setAttribute('d', text)\n  document\n    .getElementById('path-dist')!\n    .setAttribute(\n      'd',\n      svg.pathSegmentRawsToString(\n        svg.reversePath(svg.parsePathSegmentRaws(text))\n      )\n    )\n}\nrunReverse()\ndocument.getElementById('run-reverse')!.addEventListener('click', runReverse)\n\nfunction runModify() {\n  const text = (document.getElementById('input-path2') as HTMLInputElement)!\n    .value\n\n  document.getElementById('path-src2')!.setAttribute('d', text)\n  const segs = svg.parsePathSegmentRaws(text)\n  document\n    .getElementById('path-dist2')!\n    .setAttribute(\n      'd',\n      svg.pathSegmentRawsToString(svg.slidePath(segs, { x: 30, y: 30 }))\n    )\n  document\n    .getElementById('path-dist3')!\n    .setAttribute(\n      'd',\n      svg.pathSegmentRawsToString(svg.scalePath(segs, { x: -1, y: 1 }))\n    )\n  document\n    .getElementById('path-dist4')!\n    .setAttribute(\n      'd',\n      svg.pathSegmentRawsToString(svg.scalePath(segs, { x: 1, y: -1 }))\n    )\n  document\n    .getElementById('path-dist5')!\n    .setAttribute(\n      'd',\n      svg.pathSegmentRawsToString(svg.scalePath(segs, { x: -1, y: -1 }))\n    )\n}\nrunModify()\ndocument.getElementById('run-modify')!.addEventListener('click', runModify)\n\nfunction runRotate() {\n  const text = (document.getElementById('input-rotate') as HTMLInputElement)!\n    .value\n\n  document.getElementById('rotate-src2')!.setAttribute('d', text)\n  const segs = svg.parsePathSegmentRaws(text)\n  document\n    .getElementById('rotate-dist2')!\n    .setAttribute(\n      'd',\n      svg.pathSegmentRawsToString(svg.rotatePath(segs, (2 * Math.PI) / 5))\n    )\n  document\n    .getElementById('rotate-dist3')!\n    .setAttribute(\n      'd',\n      svg.pathSegmentRawsToString(svg.rotatePath(segs, (2 * (Math.PI * 2)) / 5))\n    )\n  document\n    .getElementById('rotate-dist4')!\n    .setAttribute(\n      'd',\n      svg.pathSegmentRawsToString(svg.rotatePath(segs, (2 * (Math.PI * 3)) / 5))\n    )\n  document\n    .getElementById('rotate-dist5')!\n    .setAttribute(\n      'd',\n      svg.pathSegmentRawsToString(svg.rotatePath(segs, (2 * (Math.PI * 4)) / 5))\n    )\n}\nrunRotate()\ndocument.getElementById('run-rotate')!.addEventListener('click', runRotate)\n","import { IVec2, IRectangle, AffineMatrix } from './types'\n\nexport const MINVALUE: number = 0.000001\n\nexport const IDENTITY_AFFINE: AffineMatrix = [1, 0, 0, 1, 0, 0]\n\nexport function vec(x: number, y: number): IVec2 {\n  return { x, y }\n}\n\nexport function add(a: IVec2, b: IVec2): IVec2 {\n  return vec(a.x + b.x, a.y + b.y)\n}\n\nexport function sub(a: IVec2, b: IVec2): IVec2 {\n  return vec(a.x - b.x, a.y - b.y)\n}\n\nexport function multi(a: IVec2, b: number): IVec2 {\n  return vec(a.x * b, a.y * b)\n}\n\nexport function isSame(a: IVec2, b: IVec2): boolean {\n  const dif: IVec2 = sub(a, b)\n  return Math.abs(dif.x) < MINVALUE && Math.abs(dif.y) < MINVALUE\n}\n\nexport function getDistance(a: IVec2, b: IVec2): number {\n  return getNorm(sub(a, b))\n}\n\nexport function getDistanceSq(a: IVec2, b: IVec2): number {\n  const x = a.x - b.x\n  const y = a.y - b.y\n  return x * x + y * y\n}\n\nexport function getPolylineLength(polyline: IVec2[], closed = false): number {\n  if (polyline.length < 2) return 0\n\n  let ret = 0\n  for (let i = 0; i < polyline.length - 1; i++) {\n    ret += getDistance(polyline[i], polyline[i + 1])\n  }\n  if (closed) {\n    ret += getDistance(polyline[polyline.length - 1], polyline[0])\n  }\n  return ret\n}\n\nexport function getNorm(a: IVec2): number {\n  return Math.sqrt(a.x * a.x + a.y * a.y)\n}\n\nexport function isZero(a: IVec2): boolean {\n  return getNorm(a) < MINVALUE\n}\n\nexport function getUnit(a: IVec2): IVec2 {\n  const d = getNorm(a)\n  if (d < MINVALUE) throw new Error('cannot get unit vector of zero vector')\n  return multi(a, 1 / d)\n}\n\nexport function getCross(a: IVec2, b: IVec2): number {\n  return a.x * b.y - a.y * b.x\n}\n\nexport function getInner(a: IVec2, b: IVec2): number {\n  return a.x * b.x + a.y * b.y\n}\n\nexport function cloneVectors(vectors: IVec2[]): IVec2[] {\n  return vectors.map((v) => ({ ...v }))\n}\n\nexport function getCenter(a: IVec2, b: IVec2): IVec2 {\n  return multi(add(a, b), 1 / 2)\n}\n\nexport function getRectCenter(rec: IRectangle): IVec2 {\n  return vec(rec.x + rec.width / 2, rec.y + rec.height / 2)\n}\n\nexport function getPolygonCenter(polygon: IVec2[]): IVec2 {\n  if (polygon.length === 0) return vec(0, 0)\n\n  return multi(\n    polygon.reduce((p, c) => add(p, c), vec(0, 0)),\n    1 / polygon.length\n  )\n}\n\nexport function getRadian(a: IVec2, from: IVec2 = vec(0, 0)): number {\n  const dif = sub(a, from)\n  return Math.atan2(dif.y, dif.x)\n}\n\n/**\n * fromに対して、aと点対称なベクトル取得\n * @param a 対象ベクトル\n * @param from 基点\n * @param 点対称ベクトル\n */\nexport function getSymmetry(a: IVec2, from: IVec2 = vec(0, 0)): IVec2 {\n  return add(multi(sub(from, a), 2), a)\n}\n\n/**\n * fromに対して、aからradian回転したベクトル取得\n * @param a 対象ベクトル\n * @param radian 回転ラジアン\n * @param from 基点\n * @param 回転後のベクトル\n */\nexport function rotate(\n  a: IVec2,\n  radian: number,\n  from: IVec2 = vec(0, 0)\n): IVec2 {\n  const fromBase = sub(a, from)\n  const s = Math.sin(radian)\n  const c = Math.cos(radian)\n  return add(\n    vec(c * fromBase.x - s * fromBase.y, s * fromBase.x + c * fromBase.y),\n    from\n  )\n}\n\nfunction getRotateFn(\n  radian: number,\n  from: IVec2 = vec(0, 0)\n): (a: IVec2, reverse?: boolean) => IVec2 {\n  const s = Math.sin(radian)\n  const c = Math.cos(radian)\n  return (a, reverse) => {\n    const fromBase = sub(a, from)\n    return reverse\n      ? add(\n          vec(\n            c * fromBase.x + s * fromBase.y,\n            -s * fromBase.x + c * fromBase.y\n          ),\n          from\n        )\n      : add(\n          vec(c * fromBase.x - s * fromBase.y, s * fromBase.x + c * fromBase.y),\n          from\n        )\n  }\n}\n\n/**\n * 2次方程式の解の公式\n * a * x^2 + b * x + c = 0\n * 解に虚数が含まれる場合は解なし扱い\n * @param a x^2の係数\n * @param b xの係数\n * @param c 定数\n * @return 解の配列\n */\nexport function solveEquationOrder2(a: number, b: number, c: number): number[] {\n  if (isCloseToZero(a)) {\n    return isCloseToZero(b) ? [] : [-c / b]\n  }\n\n  const d = b * b - 4 * a * c\n  if (d < 0) {\n    return []\n  }\n\n  const ia = 0.5 / a\n\n  if (isCloseToZero(d)) {\n    return [-b * ia]\n  }\n\n  const sd = Math.sqrt(d)\n  return [(-b + sd) * ia, (-b - sd) * ia]\n}\n\n/**\n * 点から直線への垂線の足\n * @param p 対象の点\n * @param line 直線\n * @return 垂線の足\n */\nexport function getPedal(p: IVec2, line: IVec2[]): IVec2 {\n  if (line.length !== 2) throw new Error('line must be length = 2')\n  const s = line[0]\n  const t = line[1]\n  const vecST = sub(t, s)\n  const vecSP = sub(p, s)\n  const inner = getInner(vecST, vecSP)\n  const rate = inner / getInner(vecST, vecST)\n  return add(s, multi(vecST, rate))\n}\n\n/**\n * 2次ベジェ曲線と直線の当たり判定用パラメータを取得する\n * @param p0 ベジェ曲線始点\n * @param p1 ベジェ曲線制御点\n * @param p2 ベジェ曲線終点\n * @param p 直線始点\n * @param q 直線終点\n * @return ベジェ曲線パラメータ配列\n */\nfunction rayToBezier(\n  p0: IVec2,\n  p1: IVec2,\n  p2: IVec2,\n  p: IVec2,\n  q: IVec2\n): number[] {\n  const vx: number = q.x - p.x\n  const vy: number = q.y - p.y\n  const a: number = p0.x - 2 * p1.x + p2.x\n  const b: number = 2 * (p1.x - p0.x)\n  const c: number = p0.x\n  const d: number = p0.y - 2 * p1.y + p2.y\n  const e: number = 2 * (p1.y - p0.y)\n  const f: number = p0.y\n\n  return solveEquationOrder2(\n    a * vy - vx * d,\n    b * vy - vx * e,\n    vy * c - vy * p.x - vx * f + vx * p.y\n  )\n}\n\n/**\n * 2次ベジェ曲「線分」と「直線」の交点を取得する\n * @method crossLineAndBezier\n * @param p0 ベジェ曲線始点\n * @param p1 ベジェ曲線制御点\n * @param p2 ベジェ曲線終点\n * @param p 直線始点\n * @param q 直線終点\n * @return 交点リスト\n */\nexport function getCrossLineAndBezier(\n  p0: IVec2,\n  p1: IVec2,\n  p2: IVec2,\n  p: IVec2,\n  q: IVec2\n): IVec2[] {\n  return rayToBezier(p0, p1, p2, p, q)\n    .filter((t) => 0 <= t && t <= 1)\n    .map((t) =>\n      vec(\n        (p2.x - 2 * p1.x + p0.x) * t * t + 2 * (p1.x - p0.x) * t + p0.x,\n        (p2.y - 2 * p1.y + p0.y) * t * t + 2 * (p1.y - p0.y) * t + p0.y\n      )\n    )\n}\n\n/**\n * 線分と線分の交差判定（端点での接触は含まない）\n * @param seg1 線分1\n * @param seg2 線分2\n * @return 交差しているフラグ\n */\nexport function isCrossSegAndSeg(seg1: IVec2[], seg2: IVec2[]): boolean {\n  const { ta, tb, tc, td } = getCrossSegAndSegParams(seg1, seg2)\n  return tc * td < 0 && ta * tb < 0\n}\n\n/**\n * 線分と線分の接触判定（端点での接触含む）\n * @param seg1 線分1\n * @param seg2 線分2\n * @return 接触しているフラグ\n */\nexport function isTouchSegAndSeg(seg1: IVec2[], seg2: IVec2[]): boolean {\n  const { ta, tb, tc, td } = getCrossSegAndSegParams(seg1, seg2)\n  return tc * td <= 0 && ta * tb <= 0\n}\n\nfunction getCrossSegAndSegParams(\n  seg1: IVec2[],\n  seg2: IVec2[]\n): {\n  ta: number\n  tb: number\n  tc: number\n  td: number\n} {\n  const ax = seg1[0].x\n  const ay = seg1[0].y\n  const bx = seg1[1].x\n  const by = seg1[1].y\n  const cx = seg2[0].x\n  const cy = seg2[0].y\n  const dx = seg2[1].x\n  const dy = seg2[1].y\n  const ta = (cx - dx) * (ay - cy) + (cy - dy) * (cx - ax)\n  const tb = (cx - dx) * (by - cy) + (cy - dy) * (cx - bx)\n  const tc = (ax - bx) * (cy - ay) + (ay - by) * (ax - cx)\n  const td = (ax - bx) * (dy - ay) + (ay - by) * (ax - dx)\n  return { ta, tb, tc, td }\n}\n\n/**\n * 平行判定\n * @param a ベクトル or 2点の配列\n * @param b 同上\n * @return 平行であるフラグ\n */\nexport function isParallel(a: IVec2, b: IVec2): boolean {\n  const cross = getCross(a, b)\n  return Math.abs(cross) < MINVALUE\n}\n\n/**\n * 点が直線上にあるか判定\n * @param p 点\n * @param line 直線\n * @return 直線上にあるフラグ\n */\nexport function isOnLine(p: IVec2, line: IVec2[]): boolean {\n  return isZero(sub(p, getPedal(p, line)))\n}\n\n/**\n * 点が線分上にあるか判定\n * @param p 点\n * @param seg 線分\n * @return 線分上にあるフラグ\n */\nexport function isOnSeg(p: IVec2, seg: IVec2[]): boolean {\n  if (!isZero(sub(p, getPedal(p, seg)))) return false\n  const v1 = sub(seg[1], seg[0])\n  const v2 = sub(p, seg[0])\n  if (getInner(v1, v2) < 0) return false\n  if (getNorm(v1) < getNorm(v2)) return false\n  return true\n}\n\n/**\n * 点から正の方向へ伸ばした水平線が線分と交差するか判定\n * 点が面上にあるか判定に利用する\n * 点が線分上の場合はfalse\n * @param p 点\n * @param seg 線分\n * @return 交差するフラグ\n */\nfunction isCrossSegAndRightHorizon(p: IVec2, seg: IVec2[]): boolean {\n  // 平行な場合はfalse\n  if (Math.abs(seg[0].y - seg[1].y) < MINVALUE) {\n    return false\n  }\n\n  // 線分の上側端点との接触はfalse、下側端点との接触はtrueで統一\n  let top, bottom\n  if (seg[0].y < seg[1].y) {\n    ;[bottom, top] = seg\n  } else {\n    ;[top, bottom] = seg\n  }\n  if (p.y < bottom.y || top.y <= p.y) {\n    return false\n  }\n\n  // 交点は厳密にpの右側でなければいけない\n  const cross = getCrossSegAndLine(seg, [p, vec(p.x + 1, p.y)])\n  if (!cross || cross.x <= p.x) {\n    return false\n  }\n\n  return true\n}\n\n/**\n * 点が面上にあるか判定（境界線上を含む）\n * @param p 点\n * @param polygon 面\n * @return 面上にあるフラグ\n */\nexport function isOnPolygon(p: IVec2, polygon: IVec2[]): boolean {\n  // 頂点上判定\n  if (polygon.find((point) => p.x === point.x && p.y === point.y)) return true\n\n  const segs: IVec2[][] = polygon\n    .map((point, i) => {\n      return [point, i < polygon.length - 1 ? polygon[i + 1] : polygon[0]]\n    })\n    // 長さ0の辺は扱わない\n    .filter((seg) => !isSame(seg[0], seg[1]))\n\n  // 辺上判定\n  for (let i = 0; i < segs.length; i++) {\n    const seg = segs[i]\n    if (isOnSeg(p, seg)) {\n      return true\n    }\n  }\n\n  const hitSegs = segs.filter((seg) => isCrossSegAndRightHorizon(p, seg))\n  return hitSegs.length % 2 === 1\n}\n\n/**\n * 線分と直線の交点取得\n * @param seg 線分\n * @param line 直線\n * @return 交点\n */\nexport function getCrossSegAndLine(seg: IVec2[], line: IVec2[]): IVec2 | null {\n  if (isParallel(sub(seg[0], seg[1]), sub(line[0], line[1]))) return null\n  if (isOnLine(seg[0], line)) return { ...seg[0] }\n  if (isOnLine(seg[1], line)) return { ...seg[1] }\n\n  const s1 =\n    ((line[1].x - line[0].x) * (seg[0].y - line[0].y) -\n      (line[1].y - line[0].y) * (seg[0].x - line[0].x)) /\n    2\n  const s2 =\n    ((line[1].x - line[0].x) * (line[0].y - seg[1].y) -\n      (line[1].y - line[0].y) * (line[0].x - seg[1].x)) /\n    2\n  const rate = s1 / (s1 + s2)\n  const isExistCorss = 0 < rate && rate < 1\n\n  return isExistCorss\n    ? vec(\n        seg[0].x + (seg[1].x - seg[0].x) * rate,\n        seg[0].y + (seg[1].y - seg[0].y) * rate\n      )\n    : null\n}\n\n/**\n * 同一線分かを判定する\n * @param ab 線分ab\n * @param cd 線分cd\n * @return 同一であるフラグ\n */\nexport function isSameSeg(ab: IVec2[], cd: IVec2[]): boolean {\n  if (isSame(ab[0], cd[0]) && isSame(ab[1], cd[1])) return true\n  if (isSame(ab[0], cd[1]) && isSame(ab[1], cd[0])) return true\n  return false\n}\n\n/**\n * ポリゴンを直線で分割する\n * @param pol 面\n * @param line 直線\n * @return 分割された点配列の配列\n */\nexport function splitPolyByLine(pol: IVec2[], line: IVec2[]): IVec2[][] {\n  let points: IVec2[] = []\n  let crossIndex: number[] = []\n  let crossList: IVec2[] = []\n\n  pol.forEach((p, i) => {\n    const targetLine = [p, pol[(i + 1) % pol.length]]\n    const cross = getCrossSegAndLine(targetLine, line)\n    points.push(p)\n    if (cross) {\n      points.push(cross)\n      crossIndex.push(i + 1 + crossIndex.length)\n      crossList.push(cross)\n    }\n  })\n\n  if (crossIndex.length % 2 !== 0) return []\n\n  // 近い順に並べる -> 直線をx軸と重なるよう回転してx座標で比較\n  const rad: number = getRadian(line[0], line[1])\n  crossList.sort((a, b) => rotate(a, -rad).x - rotate(b, -rad).x)\n\n  // 面の辺と同一ではないものを採用\n  let targetSection: IVec2[] = []\n  for (let k = 0; k < crossList.length - 1; k += 2) {\n    const section = [crossList[k], crossList[k + 1]]\n    let sameSeg = false\n    for (let l = 0; l < pol.length; l++) {\n      if (isSameSeg(section, [pol[l], pol[(l + 1) % pol.length]])) {\n        sameSeg = true\n        break\n      }\n    }\n\n    if (!sameSeg) {\n      targetSection = section\n      break\n    }\n  }\n\n  if (targetSection.length !== 2) return []\n\n  // 除外対象回収\n  const dropList = crossList.concat()\n  let tmpIndex = dropList.indexOf(targetSection[0])\n  if (tmpIndex !== -1) {\n    dropList.splice(tmpIndex, 1)\n  }\n  tmpIndex = dropList.indexOf(targetSection[1])\n  if (tmpIndex !== -1) {\n    dropList.splice(tmpIndex, 1)\n  }\n  const tmpList = points.concat()\n  dropList.forEach((p) => {\n    const i = tmpList.indexOf(p)\n    tmpList.splice(i, 1)\n  })\n\n  points = tmpList\n  crossList = targetSection\n\n  const i0 = points.indexOf(crossList[0])\n  const i1 = points.indexOf(crossList[1])\n\n  if (i0 === -1 || i1 === -1) return []\n\n  crossIndex = []\n  crossIndex[0] = Math.min(i0, i1)\n  crossIndex[1] = Math.max(i0, i1)\n\n  // 分割ポリゴンを拾い集める\n  const splitedPolygons = []\n\n  // 1つ目\n  let splitPol = []\n  // 交点まで追加\n  for (let i = 0; i <= crossIndex[0]; i++) {\n    splitPol.push(vec(points[i].x, points[i].y))\n  }\n  // 交点から追加\n  for (let i = crossIndex[1]; i < points.length; i++) {\n    splitPol.push(vec(points[i].x, points[i].y))\n  }\n  // 確定\n  splitedPolygons.push(splitPol)\n\n  // 2つ目\n  splitPol = []\n  // 交点から交点まで追加\n  for (let i = crossIndex[0]; i <= crossIndex[1]; i++) {\n    splitPol.push(vec(points[i].x, points[i].y))\n  }\n  // 確定\n  splitedPolygons.push(splitPol)\n\n  // 再帰的に分割\n  const recursiveResult: IVec2[][] = []\n  splitedPolygons.forEach((polygon) => {\n    const splited = splitPolyByLine(polygon, line)\n    if (splited.length === 0) {\n      recursiveResult.push(polygon)\n    } else {\n      recursiveResult.push(...splited)\n    }\n  })\n\n  return recursiveResult\n}\n\n/**\n * 三角分割\n * @param polygon 面\n * @return 分割面リスト\n */\nexport function triangleSplit(polygon: IVec2[]): IVec2[][] {\n  // 時計周りに揃える\n  polygon = convertLoopwise(polygon)\n\n  // ポリゴン複製\n  const targetPoly = omitSamePoint(polygon)\n\n  // 最遠点のインデックス\n  let farthestIndex = 0\n  // 現在の最遠点と前後点で作った三角形の外積\n  let currentCross = 0\n  // 分割後の面リスト\n  const triangleList = []\n\n  // ループ\n  while (targetPoly.length >= 3) {\n    // 最遠点インデックス取得\n    const sorted = targetPoly.concat()\n    sorted.sort((a, b) => {\n      return getNorm(b) - getNorm(a)\n    })\n    farthestIndex = targetPoly.indexOf(sorted[0])\n\n    // 分割実行\n    let tri = getTriangle(targetPoly, farthestIndex)\n    if (!tri) {\n      // 最遠点では失敗\n      const size = targetPoly.length\n      // 外積計算\n      const pa = sub(\n        targetPoly[(farthestIndex + 1) % size],\n        targetPoly[farthestIndex]\n      )\n      const pb = sub(\n        targetPoly[farthestIndex - 1 < 0 ? size - 1 : farthestIndex - 1],\n        targetPoly[farthestIndex]\n      )\n\n      currentCross = getCross(pa, pb)\n\n      let index = farthestIndex\n      // 最遠点以外で探す\n      while (!tri) {\n        index = (index + 1) % size\n        // 最遠点の外積と同じ符号かを判定\n        const v1 = sub(targetPoly[(index + 1) % size], targetPoly[index])\n        const v2 = sub(\n          targetPoly[index - 1 < 0 ? size - 1 : index - 1],\n          targetPoly[index]\n        )\n        const tmpCross = getCross(v1, v2)\n        if (tmpCross * currentCross > 0) {\n          // 判定続行\n          tri = getTriangle(targetPoly, index)\n        }\n        if (index === farthestIndex) {\n          throw new Error('failed to split triangles')\n        }\n      }\n\n      // 採用された点を削除\n      targetPoly.splice(index, 1)\n    } else {\n      // 最遠点削除\n      targetPoly.splice(farthestIndex, 1)\n    }\n    triangleList.push(tri)\n  }\n  return triangleList\n}\n\n/**\n * 面から三角形を取得する\n * @param polygon 面\n * @param index このインデックスの点とその両側の点で三角形を作る\n * @return 三角形、内部に入り込む点がある場合はnull\n */\nfunction getTriangle(polygon: IVec2[], index: number): IVec2[] | null {\n  // indexとその前後点で三角形作成\n  const size = polygon.length\n  const p0 = polygon[index]\n  const p1 = polygon[(index + 1) % size]\n  const p2 = polygon[index - 1 < 0 ? size - 1 : index - 1]\n\n  const tri: IVec2[] = [p0, p1, p2]\n\n  // 内部に点が入り込まないか判定\n  let invalid: boolean = false\n  polygon.some((p) => {\n    if (p !== p0 && p !== p1 && p !== p2) {\n      if (isPointOnTriangle(tri, p)) {\n        // 失敗\n        invalid = true\n      }\n    }\n    return invalid\n  })\n\n  return invalid ? null : tri\n}\n\n/**\n * 点が三角形内にあるかを判定する\n * 境界も含む\n * @param tri 三角形\n * @param p 点\n * @return 内部にあるフラグ\n */\nexport function isPointOnTriangle(tri: IVec2[], p: IVec2): boolean {\n  // 三角形の3つのベクトル\n  const ab = sub(tri[1], tri[0])\n  const bc = sub(tri[2], tri[1])\n  const ca = sub(tri[0], tri[2])\n\n  // 三角形の各点からpへのベクトル\n  const ap = sub(p, tri[0])\n  const bp = sub(p, tri[1])\n  const cp = sub(p, tri[2])\n\n  // 外積を求める\n  const crossABP = getCross(ab, bp)\n  const crossBCP = getCross(bc, cp)\n  const crossCAP = getCross(ca, ap)\n\n  // 外積の符号が全て同じなら内部にある\n  // 0も含む→境界も含む\n  if (\n    (crossABP >= 0 && crossBCP >= 0 && crossCAP >= 0) ||\n    (crossABP <= 0 && crossBCP <= 0 && crossCAP <= 0)\n  ) {\n    return true\n  }\n\n  return false\n}\n\n/**\n * 面を時計回りに変換する\n * @param {vector[]} 面\n * @return 時計回りにした面(引数とは別配列にする)\n */\nexport function convertLoopwise(polygon: IVec2[]): IVec2[] {\n  const ret = polygon.concat()\n  if (getLoopwise(polygon) === -1) {\n    ret.reverse()\n  }\n  return ret\n}\n\n/**\n * 面の座標が時計回りかを判定する\n * @param polygon 面\n * @return -1:反時計 0:不定 1:時計\n */\nexport function getLoopwise(polygon: IVec2[]): number {\n  const area = getArea(polygon, true)\n  if (area > 0) return 1\n  if (area < 0) return -1\n  return 0\n}\n\n/**\n * 面積取得\n * @param polygon 面\n * @param allowNegative 負値を許すフラグ\n * @return 面積\n */\nexport function getArea(\n  polygon: IVec2[],\n  allowNegative: boolean = false\n): number {\n  if (polygon.length < 3) return 0\n\n  let area = 0\n  const size = polygon.length\n  for (let i = 0; i < size - 1; i++) {\n    area +=\n      (polygon[i].x - polygon[i + 1].x) * (polygon[i].y + polygon[i + 1].y)\n  }\n  // 最後分\n  area +=\n    (polygon[size - 1].x - polygon[0].x) * (polygon[size - 1].y + polygon[0].y)\n\n  area /= 2\n\n  // 負値を許さないなら絶対値\n  if (!allowNegative) {\n    area = Math.abs(area)\n  }\n\n  return area\n}\n\n/**\n * ベジェ曲線を直線で近似する(３次まで対応)\n * @param pointList 制御点リスト\n * @param size 分割数(1なら制御点両端のみ)\n * @return 座標リスト\n */\nexport function approximateBezier(pointList: IVec2[], size: number): IVec2[] {\n  const ret: IVec2[] = []\n  const unitT: number = 1 / size\n\n  if (pointList.length === 3) {\n    // ２次ベジェの場合\n    for (let i = 0; i <= size; i++) {\n      ret.push(getPointOnBezier2(pointList as [IVec2, IVec2, IVec2], unitT * i))\n    }\n  } else if (pointList.length === 4) {\n    // 3次ベジェの場合\n    for (let i = 0; i <= size; i++) {\n      ret.push(\n        getPointOnBezier3(pointList as [IVec2, IVec2, IVec2, IVec2], unitT * i)\n      )\n    }\n  } else {\n    throw new Error('connot approximate')\n  }\n\n  return ret\n}\n\n/**\n * get point with the rate on bezier2\n * @param pointList controller points\n * @param rate rate between start point and end point\n * @return calced point\n */\nexport function getPointOnBezier2(\n  pointList: Readonly<[IVec2, IVec2, IVec2]>,\n  rate: number\n): IVec2 {\n  const t = rate\n  const nt = 1 - t\n  const c0 = multi(pointList[0], nt * nt)\n  const c1 = multi(pointList[1], 2 * t * nt)\n  const c2 = multi(pointList[2], t * t)\n  return vec(c0.x + c1.x + c2.x, c0.y + c1.y + c2.y)\n}\n\nexport function getBezier2LerpFn(\n  pointList: Readonly<[IVec2, IVec2, IVec2]>\n): (t: number) => IVec2 {\n  return (t) => getPointOnBezier2(pointList, t)\n}\n\n/**\n * get point with the rate on bezier3\n * @param pointList controller points\n * @param rate rate between start point and end point\n * @return calced point\n */\nexport function getPointOnBezier3(\n  pointList: Readonly<Bezier3>,\n  rate: number\n): IVec2 {\n  const t = rate\n  const nt = 1 - t\n  const c0 = multi(pointList[0], nt * nt * nt)\n  const c1 = multi(pointList[1], 3 * t * nt * nt)\n  const c2 = multi(pointList[2], 3 * t * t * nt)\n  const c3 = multi(pointList[3], t * t * t)\n  return vec(c0.x + c1.x + c2.x + c3.x, c0.y + c1.y + c2.y + c3.y)\n}\n\nexport function getBezier3LerpFn(\n  pointList: Readonly<Bezier3>\n): (t: number) => IVec2 {\n  return (t) => getPointOnBezier3(pointList, t)\n}\n\n/**\n * get point with the rate on bezier3\n * need these conditions to get unique value\n * p0.x <= p1.x <= p3.x\n * p0.x <= p2.x <= p3.x\n * or may cause unexpected NaN\n * @param pointList controller points [p0, p1, p2, p3]\n * @param rate rate between start point and end point\n * @return calced point\n */\nexport function getYOnBezier3AtX(\n  pointList: Readonly<Bezier3>,\n  x: number\n): number {\n  const [p0, p1, p2, p3] = pointList\n  const a = -p0.x + 3 * p1.x - 3 * p2.x + p3.x\n  const b = 3 * p0.x - 6 * p1.x + 3 * p2.x\n  const c = -3 * p0.x + 3 * p1.x\n  const d = p0.x - x\n\n  const t = solveBezier3Fomula(a, b, c, d)\n  const tt = t * t\n  const ttt = tt * t\n  const tm = 1 - t\n  const tmtm = tm * tm\n  const tmtmtm = tmtm * tm\n\n  return tmtmtm * p0.y + 3 * t * tmtm * p1.y + 3 * tt * tm * p2.y + ttt * p3.y\n}\n\n/**\n * 円弧を直線で近似する\n * @param rx x軸半径\n * @param ry y軸半径\n * @param startRadian 開始ラジアン\n * @param endRadian 終了ラジアン\n * @param center 中心座標\n * @param radian 傾き\n * @param size 分割数\n * @return 座標リスト\n */\nexport function approximateArc(\n  rx: number,\n  ry: number,\n  startRadian: number,\n  endRadian: number,\n  center: IVec2,\n  radian: number,\n  size: number\n): IVec2[] {\n  const ret = []\n  const range = endRadian - startRadian\n  const unitT = range / size\n  const rotateFn = getRotateFn(radian)\n\n  for (let i = 0; i <= size; i++) {\n    const t = unitT * i + startRadian - radian\n    ret.push(add(rotateFn(vec(rx * Math.cos(t), ry * Math.sin(t))), center))\n  }\n\n  return ret\n}\n\n/**\n * Approximate arc path as a polyline\n * https://www.w3.org/TR/SVG11/implnote.html#ArcImplementationNotes\n * @method approximateArcWithPoint\n * @param rx x軸半径\n * @param ry y軸半径\n * @param startPoint 開始点\n * @param endPoint 終了点\n * @param largeArcFlag 円弧の大きい側を使うフラグ\n * @param sweepFlag 時計回り円弧を使うフラグ\n * @param radian 傾き\n * @param size 分割数\n * @return 座標リスト\n */\nexport function approximateArcWithPoint(\n  rx: number,\n  ry: number,\n  startPoint: IVec2,\n  endPoint: IVec2,\n  largeArcFlag: boolean,\n  sweepFlag: boolean,\n  radian: number,\n  size: number\n): IVec2[] {\n  if (Math.abs(rx * ry) < MINVALUE) {\n    return [startPoint, endPoint]\n  }\n  return getApproPoints(\n    getArcLerpFn(rx, ry, startPoint, endPoint, largeArcFlag, sweepFlag, radian),\n    size\n  )\n}\n\nexport function getArcLerpFn(\n  rx: number,\n  ry: number,\n  startPoint: IVec2,\n  endPoint: IVec2,\n  largeArcFlag: boolean,\n  sweepFlag: boolean,\n  radian: number\n): (t: number) => IVec2 {\n  if (Math.abs(rx * ry) < MINVALUE) {\n    return (t) => lerpPoint(startPoint, endPoint, t)\n  }\n\n  const r = radian\n  const rotateFn = getRotateFn(r)\n  const p0 = startPoint\n  const p1 = endPoint\n  const a = rotateFn(vec((p0.x - p1.x) / 2, (p0.y - p1.y) / 2), true)\n  const ax2 = a.x * a.x\n  const ay2 = a.y * a.y\n\n  const l = ax2 / rx / rx + ay2 / ry / ry\n  const lsqrt = l > 1 ? Math.sqrt(l) : 1\n  const { x: rxa, y: rya } = vec(Math.abs(rx) * lsqrt, Math.abs(ry) * lsqrt)\n\n  const rx2 = rxa * rxa\n  const ry2 = rya * rya\n  const b = multi(\n    multi(\n      vec((rxa * a.y) / rya, (-rya * a.x) / rxa),\n      Math.sqrt(\n        Math.max(0, rx2 * ry2 - rx2 * ay2 - ry2 * ax2) / (rx2 * ay2 + ry2 * ax2)\n      )\n    ),\n    largeArcFlag === sweepFlag ? -1 : 1\n  )\n\n  const c = add(rotateFn(b), multi(add(p0, p1), 0.5))\n\n  const u = vec((a.x - b.x) / rxa, (a.y - b.y) / rya)\n  const v = vec((-a.x - b.x) / rxa, (-a.y - b.y) / rya)\n  const theta = getRadian(u)\n  const dtheta_tmp = (getRadian(v) - getRadian(u)) % (2 * Math.PI)\n  const dtheta =\n    !sweepFlag && 0 < dtheta_tmp\n      ? dtheta_tmp - 2 * Math.PI\n      : sweepFlag && dtheta_tmp < 0\n      ? dtheta_tmp + 2 * Math.PI\n      : dtheta_tmp\n\n  return (t) => {\n    if (t === 0) {\n      return startPoint\n    } else if (t === 1) {\n      return endPoint\n    } else {\n      const dr = theta + dtheta * t\n      return add(rotateFn(vec(rxa * Math.cos(dr), rya * Math.sin(dr))), c)\n    }\n  }\n}\n\nexport function lerpPoint(a: IVec2, b: IVec2, t: number): IVec2 {\n  return add(a, multi(sub(b, a), t))\n}\n\nexport function getApproPoints(\n  lerpFn: (t: number) => IVec2,\n  split: number\n): IVec2[] {\n  if (split <= 1) {\n    return [lerpFn(0), lerpFn(1)]\n  }\n\n  const points: IVec2[] = []\n  let step = 1 / split\n  for (let i = 0; i <= split; i++) {\n    points.push(lerpFn(step * i))\n  }\n  return points\n}\n\n/**\n * ２点を通る楕円の中心を求める\n * @param a 点a\n * @param b 点b\n * @param rx x軸半径\n * @param ry y軸半径\n * @param radian 傾き\n * @return 解となる２点\n * @return { centers: 解となる２点, radiusRate: 半径補正係数 }\n */\nexport function getEllipseCenter(\n  a: IVec2,\n  b: IVec2,\n  rx: number,\n  ry: number,\n  radian: number\n): { centers: IVec2[]; radiusRate: number } {\n  // 回転を打ち消す\n  a = rotate(a, -radian)\n  b = rotate(b, -radian)\n\n  // 媒介変数を利用して円の中心問題にする\n  const A = vec(a.x / rx, a.y / ry)\n  const B = vec(b.x / rx, b.y / ry)\n\n  // 円の中心取得\n  const centerInfo = getCircleCenter(A, B, 1)\n  const C = centerInfo.centers\n\n  // 楕円に戻す\n  let ans1 = vec(C[0].x * rx, C[0].y * ry)\n  let ans2 = vec(C[1].x * rx, C[1].y * ry)\n\n  // 回転を戻す\n  ans1 = rotate(ans1, radian)\n  ans2 = rotate(ans2, radian)\n\n  return {\n    centers: [ans1, ans2],\n    radiusRate: centerInfo.radiusRate,\n  }\n}\n\n/**\n * ２点を通る円の中心を求める\n * @param a 点a\n * @param b 点b\n * @param radius 半径\n * @return { centers: 解となる２点, radiusRate: 半径補正係数 }\n */\nexport function getCircleCenter(\n  a: IVec2,\n  b: IVec2,\n  radius: number\n): { centers: IVec2[]; radiusRate: number } {\n  const u1 = (a.x + b.x) / 2\n  const u2 = (a.x - b.x) / 2\n  const v1 = (a.y + b.y) / 2\n  const v2 = (a.y - b.y) / 2\n  const L = Math.sqrt(u2 * u2 + v2 * v2)\n  const t2 = Math.pow(radius / L, 2) - 1\n\n  // 2点が直径以上に離れている => 2点を直径とみなす\n  if (t2 < 0) {\n    const center = getCenter(a, b)\n    return {\n      centers: [center, center],\n      radiusRate: L / radius,\n    }\n  }\n\n  const t = Math.sqrt(t2)\n  const ans1 = vec(u1 + v2 * t, v1 - u2 * t)\n  const ans2 = vec(u1 - v2 * t, v1 + u2 * t)\n\n  return {\n    centers: [ans1, ans2],\n    radiusRate: 1,\n  }\n}\n\n/**\n * 2次元アフィン変換を行う\n * paramsには以下の行列をa b c d e fの順で指定する\n * a c e\n * b d f\n * @param points 変換前の座標リスト\n * @param params 行列成分\n * @return 座標リスト\n */\nexport function transform(points: IVec2[], params: number[]): IVec2[] {\n  const a = params[0]\n  const b = params[1]\n  const c = params[2]\n  const d = params[3]\n  const e = params[4]\n  const f = params[5]\n\n  return points.map((p) => vec(a * p.x + c * p.y + e, b * p.x + d * p.y + f))\n}\n\n/**\n * invert affine transfomation matrix\n * a c e\n * b d f\n * @param params [a, b, c, d, e, f]\n * @return inverted matrix params\n */\nexport function invertTransform(params: AffineMatrix): AffineMatrix {\n  const [a, b, c, d, e, f] = params\n  const t = a * d - b * c\n  return [\n    d / t,\n    -b / t,\n    -c / t,\n    a / t,\n    (c * f - d * e) / t,\n    -(a * f - b * e) / t,\n  ]\n}\n\n/**\n * multi affine transfomation matrixes\n * @param a affine matrix\n * @param b affine matrix\n * @return a * b\n */\nexport function multiAffine(a: AffineMatrix, b: AffineMatrix): AffineMatrix {\n  return [\n    a[0] * b[0] + a[2] * b[1],\n    a[1] * b[0] + a[3] * b[1],\n    a[0] * b[2] + a[2] * b[3],\n    a[1] * b[2] + a[3] * b[3],\n    a[0] * b[4] + a[2] * b[5] + a[4],\n    a[1] * b[4] + a[3] * b[5] + a[5],\n  ]\n}\n\n/**\n * multi affines\n * @param affines affine matrix list\n * @return affines[0] * affines[1] * ...\n */\nexport function multiAffines(affines: AffineMatrix[]): AffineMatrix {\n  return affines.reduce((p, c) => {\n    return multiAffine(p, c)\n  }, IDENTITY_AFFINE)\n}\n\n/**\n * apply affine\n * @param affine affine matrix\n * @param v vector2\n * @return affine x v\n */\nexport function applyAffine(affine: AffineMatrix, v: IVec2): IVec2 {\n  return vec(\n    affine[0] * v.x + affine[2] * v.y + affine[4],\n    affine[1] * v.x + affine[3] * v.y + affine[5]\n  )\n}\n\n/**\n * 隣り合う同一点をオミットする\n * @method omitSamePoint\n * @param polygon ポリゴン\n * @return オミット後のポリゴン\n */\nexport function omitSamePoint(polygon: IVec2[]): IVec2[] {\n  let ret = polygon.concat()\n\n  // サイズ\n  const size = polygon.length\n  // 同一点探す\n  for (let i = 0; i < size; i++) {\n    const p1 = ret[i]\n    const p2 = ret[(i + 1) % size]\n    if (isSame(p1, p2)) {\n      // 同一\n      ret.splice(i, 1)\n      // 再帰\n      ret = omitSamePoint(ret)\n      break\n    }\n  }\n\n  return ret\n}\n\n/**\n * 正多角形の面積を内接円の半径から求める\n * @param radius 半径\n * @param n 角数\n * @return 面積\n */\nexport function getRegularPolygonArea(radius: number, n: number): number {\n  const unitRad = Math.PI / n\n  const unitArea = Math.pow(radius, 2) * Math.sin(unitRad) * Math.cos(unitRad)\n  return unitArea * n\n}\n\n/**\n * 正多角形の面積から内接円の半径を求める\n * @param area 面積\n * @param n 角数\n * @return 半径\n */\nexport function getRegularPolygonRadius(area: number, n: number): number {\n  const unitRad = Math.PI / n\n  const unitArea = area / n\n  return Math.sqrt(unitArea / Math.sin(unitRad) / Math.cos(unitRad))\n}\n\n/**\n * 包含関係にあるポリゴンをグループ化する\n * @param polygons ポリゴン一覧\n * @return グループ化したポリゴン一覧、グループ内は面積降順\n */\nexport function getIncludedPolygonGroups(polygons: IVec2[][]): IVec2[][][] {\n  const sorted = polygons.concat()\n  sorted.sort((a, b) => {\n    return getArea(b) - getArea(a)\n  })\n  const hit: { [s: string]: boolean } = {}\n  const ret: IVec2[][][] = []\n  sorted.forEach((p, i) => {\n    if (hit[i]) return\n    hit[i] = true\n    const group = [p].concat(\n      sorted.filter((c, j) => {\n        if (hit[j]) return false\n        const pointsOnPolygon = c.filter((point) => isOnPolygon(point, p))\n        if (pointsOnPolygon.length !== c.length) return false\n        hit[j] = true\n        return true\n      })\n    )\n    ret.push(group)\n  })\n  return ret\n}\n\n/**\n * ポリゴンブーリアン演算差\n * 突き抜けは非対応\n * targetは1辺のみでpolyと交差する前提\n * targetとpolyは観点方向が逆である前提\n * @param target ポリゴン\n * @param poly 切り取り範囲ポリゴン\n * @return 切り取った後のポリゴン\n */\nexport function getPolygonNotPolygon(target: IVec2[], poly: IVec2[]): IVec2[] {\n  const ret: IVec2[] = []\n\n  // targetの辺と交差するpolyの辺インデックスを探索\n  let targetCrossIndex: number = -1\n  const polyCrossIndexList: number[] = []\n  const cross: IVec2[] = []\n  for (let i = 0; i < target.length; i++) {\n    const currentSeg = [target[i], target[(i + 1) % target.length]]\n    for (let j = 0; j < poly.length; j++) {\n      const seg = [poly[j], poly[(j + 1) % poly.length]]\n      if (isCrossSegAndSeg(currentSeg, seg)) {\n        const p = getCrossSegAndLine(currentSeg, seg)\n        if (p) {\n          targetCrossIndex = i\n          polyCrossIndexList.push(j)\n          cross.push(p)\n        }\n      }\n    }\n    if (targetCrossIndex !== -1) break\n  }\n\n  if (targetCrossIndex === -1) return target\n  if (polyCrossIndexList.length % 2 !== 0) return target\n\n  // target辺の始点に最も近い交点を探す\n  const distList = cross.map((p) => getDistance(p, target[targetCrossIndex]))\n  const sortedDistList = distList.concat().sort((a, b) => a - b)\n  const nearestCrossIndex = distList.indexOf(sortedDistList[0])\n  const nearestIndex = polyCrossIndexList[nearestCrossIndex]\n\n  // nearestIndexが始点となるようpolyを調整\n  const adjustedPoly: IVec2[] = poly.concat()\n  for (let j = 0; j < nearestIndex; j++) {\n    adjustedPoly.push(adjustedPoly.shift() as IVec2)\n  }\n  // nearestIndexが先頭になるよう調整\n  const adjustedPolyCrossIndexList: number[] = polyCrossIndexList.map((n) => {\n    return (n - nearestIndex + poly.length) % poly.length\n  })\n  const adjustedCross: IVec2[] = cross.concat()\n  for (let k = 0; k < nearestCrossIndex; k++) {\n    adjustedPolyCrossIndexList.push(\n      adjustedPolyCrossIndexList.shift() as number\n    )\n    adjustedCross.push(adjustedCross.shift() as IVec2)\n  }\n\n  // polyと交差する辺が始点と終点になるよう調整\n  for (let i = 0; i < target.length; i++) {\n    ret.push(target[(i + targetCrossIndex + 1) % target.length])\n  }\n\n  // 交点からpolyに突入\n  for (let i = 0; i < adjustedPolyCrossIndexList.length / 2; i++) {\n    const startIndex = adjustedPolyCrossIndexList[i * 2]\n    const endIndex = adjustedPolyCrossIndexList[i * 2 + 1]\n    ret.push(adjustedCross[i * 2])\n    for (let j = startIndex + 1; j <= endIndex; j++) {\n      ret.push(adjustedPoly[j])\n    }\n    ret.push(adjustedCross[i * 2 + 1])\n  }\n\n  return ret\n}\n\n/**\n * ポリゴン全てを包含する矩形を取得\n * @param polygons ポリゴン一覧\n * @return 外接矩形\n */\nexport function getOuterRectangle(polygons: IVec2[][]): IRectangle {\n  if (polygons.length === 0)\n    return {\n      x: 0,\n      y: 0,\n      width: 0,\n      height: 0,\n    }\n\n  let minX = Infinity\n  let minY = Infinity\n  let maxX = -Infinity\n  let maxY = -Infinity\n\n  for (let i = 0; i < polygons.length; i++) {\n    const polygon = polygons[i]\n    for (let j = 0; j < polygon.length; j++) {\n      const v = polygon[j]\n      minX = Math.min(minX, v.x)\n      minY = Math.min(minY, v.y)\n      maxX = Math.max(maxX, v.x)\n      maxY = Math.max(maxY, v.y)\n    }\n  }\n\n  return {\n    x: minX,\n    y: minY,\n    width: maxX - minX,\n    height: maxY - minY,\n  }\n}\n\n/**\n * 矩形範囲のグリッド取得\n * @param range 矩形範囲\n * @param gridSize グリッド幅\n * @param dX x軸のずらし幅\n * @param dY y軸のずらし幅\n * @return グリッド線リスト\n */\nexport function getGrid(\n  range: IRectangle,\n  gridSize: number,\n  dX: number = 0,\n  dY: number = 0\n): IVec2[][] {\n  const gridList: IVec2[][] = []\n  const minX = range.x\n  const maxX = range.x + range.width\n  const minY = range.y\n  const maxY = range.y + range.height\n\n  let x = minX + dX\n  while (x < maxX) {\n    if (minX < x && x < maxX) {\n      gridList.push([vec(x, minY), vec(x, maxY)])\n    }\n    x += gridSize\n  }\n\n  let y = minY + dY\n  while (y < maxY) {\n    if (minY < y && y < maxY) {\n      gridList.push([vec(minX, y), vec(maxX, y)])\n    }\n    y += gridSize\n  }\n\n  return gridList\n}\n\n/**\n * 矩形を中心基準でサイズ変更する\n * @param org 元の矩形\n * @param dW 幅変更差分\n * @param dH 高さ変更差分\n * @return サイズ変更後の矩形\n */\nexport function expandRecntagle(\n  org: IRectangle,\n  dW: number,\n  dH: number\n): IRectangle {\n  return {\n    x: org.x - dW / 2,\n    y: org.y - dH / 2,\n    width: org.width + dW,\n    height: org.height + dH,\n  }\n}\n\n/**\n * 矩形を中心基準の倍率でサイズ変更する\n * @param org 元の矩形\n * @param scaleW 幅変更倍率\n * @param scaleH 高さ軸変更倍率\n * @return サイズ変更後の矩形\n */\nexport function expandRecntagleScale(\n  org: IRectangle,\n  scaleW: number,\n  scaleH: number\n): IRectangle {\n  return expandRecntagle(\n    org,\n    org.width * (scaleW - 1),\n    org.height * (scaleH - 1)\n  )\n}\n\n/**\n * interpolate scaler\n * @param from\n * @param to\n * @param rate 0 => from, 1 => to\n * @return interpolated value\n */\nexport function interpolateScaler(\n  from: number,\n  to: number,\n  rate: number\n): number {\n  return from * (1 - rate) + to * rate\n}\n\n/**\n * interpolate scaler\n * @param from\n * @param to\n * @param rate 0 => from, 1 => to\n * @return interpolated value\n */\nexport function interpolateVector(from: IVec2, to: IVec2, rate: number): IVec2 {\n  return vec(\n    interpolateScaler(from.x, to.x, rate),\n    interpolateScaler(from.y, to.y, rate)\n  )\n}\n\n/**\n * solve cubic equation for bezier3\n * throw if the equation does not have real solution in 0 <= t <= 1\n * @param a t^3 param\n * @param b t^2 param\n * @param c t param\n * @param d constant param\n * @return unique solution\n */\nfunction solveBezier3Fomula(\n  a: number,\n  b: number,\n  c: number,\n  d: number\n): number {\n  const list = solveQubicFomula(a, b, c, d)\n  if (list.length === 0) return 0\n\n  const ret = getCloseInRangeValue(list, 0, 1)\n  if (ret === undefined)\n    throw new Error('Error: Cannot resolve uniquely in 0 <= t <= 1.')\n\n  return Math.max(Math.min(ret, 1), 0)\n}\n\n/**\n * solve cubic equation in real space\n * @param a t^3 param\n * @param b t^2 param\n * @param c t param\n * @param d constant param\n * @return solutions in no particular order\n */\nexport function solveQubicFomula(\n  a: number,\n  b: number,\n  c: number,\n  d: number\n): number[] {\n  if (isCloseToZero(a)) {\n    return solveEquationOrder2(b, c, d)\n  }\n\n  const p = (3 * a * c - b * b) / (3 * a * a)\n  const q = (2 * b * b * b - 9 * a * b * c + 27 * a * a * d) / (27 * a * a * a)\n\n  const Z = -b / (3 * a)\n\n  if (isCloseToZero(p) && isCloseToZero(q)) {\n    // triple real root\n    return [Z]\n  }\n\n  const D = (27 * q * q + 4 * p * p * p) / 108\n  if (isCloseToZero(D)) {\n    // one distinct root and double real root\n    const Q = Math.sign(q) * Math.pow(Math.abs(q) / 2, 1 / 3)\n    return [-2 * Q + Z, Q + Z]\n  } else if (D > 0) {\n    const sqrtD = Math.sqrt(D)\n    const tmpA = -q / 2 + sqrtD\n    const tmpB = -q / 2 - sqrtD\n    const A = Math.sign(tmpA) * Math.pow(Math.abs(tmpA), 1 / 3)\n    const B = Math.sign(tmpB) * Math.pow(Math.abs(tmpB), 1 / 3)\n\n    return [A + B + Z]\n  } else {\n    // three distinct real roots\n    const A = -q / 2\n    const B = Math.sqrt(-D)\n    const r = Math.atan2(B, A)\n    const C = 2 * Math.pow(A * A + B * B, 1 / 6)\n    const D0 = Math.cos(r / 3)\n    const D1 = Math.cos((r + 2 * Math.PI) / 3)\n    const D2 = Math.cos((r + 4 * Math.PI) / 3)\n\n    const T0 = C * D0 + Z\n    const T1 = C * D1 + Z\n    const T2 = C * D2 + Z\n\n    return [T0, T1, T2]\n  }\n}\n\nfunction getCloseInRangeValue(\n  values: number[],\n  min: number,\n  max: number\n): number | undefined {\n  return values.find((val) => {\n    if (min <= val && val <= max) return true\n    if (isCloseTo(val, min) || isCloseTo(val, max)) return true\n    return false\n  })\n}\n\nfunction isCloseTo(val: number, target: number): boolean {\n  return Math.abs(val - target) < MINVALUE\n}\n\nfunction isCloseToZero(val: number): boolean {\n  return Math.abs(val) < MINVALUE\n}\n\n/**\n * clamp number\n * @param min min value\n * @param max max value\n * @return clamped value\n */\nexport function clamp(min = -Infinity, max = Infinity, val: number): number {\n  return Math.max(Math.min(val, max), min)\n}\n\n/**\n * clamp number circularly\n * @param min min value\n * @param max max value\n * @return clamped value\n */\nexport function circleClamp(min: number, max: number, val: number): number {\n  if (min === max) return min\n  if (min <= val && val <= max) return val\n\n  if (max < val) {\n    return ((val - max) % (max - min)) + min\n  } else if (val < min) {\n    return max - ((min - val) % (max - min))\n  } else {\n    return val\n  }\n}\n\n/**\n * round trip value\n * @param min min value\n * @param max max value\n * @return round tripped value\n */\nexport function roundTrip(min: number, max: number, val: number): number {\n  const harf = max - min\n  const length = 2 * harf\n  if (length === 0) return min\n\n  const d = Math.abs(val - min) % length\n  if (d < harf) {\n    return d + min\n  } else {\n    return length - d + min\n  }\n}\n\n/**\n * Ref: https://omaraflak.medium.com/b%C3%A9zier-interpolation-8033e9a262c2\n * @param points target points to interpolate via a bezier curve\n * @return control point sets for cubic bezier curve\n */\nexport function getBezierInterpolation(\n  points: IVec2[]\n): [c0: IVec2, c1: IVec2][] {\n  const len = points.length\n  if (len < 3) return []\n\n  const A = solveBezierInterpolationEquations(points)\n  const B: IVec2[] = []\n  for (let i = 0; i < points.length - 2; i++) {\n    B[i] = sub(multi(points[i + 1], 2), A[i + 1])\n  }\n  B[points.length - 2] = multi(\n    add(A[points.length - 2], points[points.length - 1]),\n    1 / 2\n  )\n\n  return A.map((a, i) => [a, B[i]])\n}\n\n/**\n * Based on Tridiagonal matrix algorithm with bezier interpolation equation matrix.\n * Suppose \"points\" has at least 3 items.\n */\nfunction solveBezierInterpolationEquations(points: IVec2[]): IVec2[] {\n  const values: IVec2[] = [add(points[0], multi(points[1], 2))]\n  for (let i = 1; i < points.length - 2; i++) {\n    values.push(multi(add(multi(points[i], 2), points[i + 1]), 2))\n  }\n  values.push(\n    add(multi(points[points.length - 2], 8), points[points.length - 1])\n  )\n\n  const C: number[] = [0.5]\n  for (let i = 1; i < points.length - 2; i++) {\n    C[i] = 1 / (4 - C[i - 1])\n  }\n\n  const D: IVec2[] = [multi(values[0], 0.5)]\n  for (let i = 1; i < points.length - 2; i++) {\n    D[i] = multi(sub(values[i], D[i - 1]), 1 / (4 - C[i - 1]))\n  }\n  D[points.length - 2] = multi(\n    sub(values[points.length - 2], multi(D[points.length - 3], 2)),\n    1 / (7 - 2 * C[points.length - 3])\n  )\n\n  const ret: IVec2[] = []\n  ret[points.length - 2] = D[points.length - 2]\n  for (let i = points.length - 3; 0 <= i; i--) {\n    ret[i] = sub(D[i], multi(ret[i + 1], C[i]))\n  }\n\n  return ret\n}\n\n/**\n * \"points\" should be cloased manually.\n * @param points target points to interpolate via a periodic bezier curve\n * @return control point sets for cubic bezier curve\n */\nexport function getPeriodicBezierInterpolation(\n  points: IVec2[]\n): [c0: IVec2, c1: IVec2][] {\n  const len = points.length\n  if (len < 3) return []\n\n  const A = getPeriodicBezierInterpolationA(points)\n  const B: IVec2[] = []\n  for (let i = 0; i < points.length - 2; i++) {\n    B[i] = sub(multi(points[i + 1], 2), A[i + 1])\n  }\n  B[points.length - 2] = sub(multi(points[points.length - 1], 2), A[0])\n\n  return A.map((a, i) => [a, B[i]])\n}\n\nexport function getPeriodicBezierInterpolationA(points: IVec2[]): IVec2[] {\n  const paramSize = points.length - 1\n  const gamma = 1\n\n  const values: IVec2[] = []\n  for (let i = 0; i < points.length - 1; i++) {\n    values.push({\n      x: 4 * points[i].x + 2 * points[i + 1].x,\n      y: 4 * points[i].y + 2 * points[i + 1].y,\n    })\n  }\n  const y = solvePeriodicBezierInterpolationEquations(values, gamma)\n\n  const u: IVec2[] = []\n  u[0] = { x: gamma, y: gamma }\n  for (let i = 1; i < points.length - 2; i++) {\n    u.push({ x: 0, y: 0 })\n  }\n  u.push({ x: 1, y: 1 })\n  const q = solvePeriodicBezierInterpolationEquations(u, gamma)\n\n  const vy = {\n    x: y[0].x + (1 / gamma) * y[paramSize - 1].x,\n    y: y[0].y + (1 / gamma) * y[paramSize - 1].y,\n  }\n  const vq = {\n    x: q[0].x + (1 / gamma) * q[paramSize - 1].x,\n    y: q[0].y + (1 / gamma) * q[paramSize - 1].y,\n  }\n\n  const A: IVec2[] = []\n  for (let i = 0; i < paramSize; i++) {\n    A[i] = {\n      x: y[i].x - (q[i].x * vy.x) / (1 + vq.x),\n      y: y[i].y - (q[i].y * vy.y) / (1 + vq.y),\n    }\n  }\n\n  return A\n}\n\n/**\n * https://en.wikipedia.org/wiki/Tridiagonal_matrix_algorithm\n */\nfunction solvePeriodicBezierInterpolationEquations(\n  values: IVec2[],\n  gamma: number\n): IVec2[] {\n  const C: number[] = [1 / (4 - gamma)]\n  for (let i = 1; i < values.length - 1; i++) {\n    C[i] = 1 / (4 - C[i - 1])\n  }\n\n  const D: IVec2[] = [multi(values[0], 1 / (4 - gamma))]\n  for (let i = 1; i < values.length - 1; i++) {\n    D[i] = multi(sub(values[i], D[i - 1]), 1 / (4 - C[i - 1]))\n  }\n  D[values.length - 1] = multi(\n    sub(values[values.length - 1], D[values.length - 2]),\n    1 / (4 - 1 / gamma - C[values.length - 2])\n  )\n\n  const ret: IVec2[] = []\n  ret[values.length - 1] = D[values.length - 1]\n  for (let i = values.length - 2; 0 <= i; i--) {\n    ret[i] = sub(D[i], multi(ret[i + 1], C[i]))\n  }\n\n  return ret\n}\n\ntype Bezier3 = [c0: IVec2, c1: IVec2, c2: IVec2, c3: IVec2]\n\n/**\n * The order of returned items is srbitrary.\n */\nexport function getCrossSegAndBezier3(\n  seg: Readonly<[IVec2, IVec2]>,\n  bezier: Readonly<Bezier3>\n): IVec2[] {\n  return getCrossSegAndBezier3WithT(seg, bezier).map(([p]) => p)\n}\n\nexport function getCrossSegAndBezier3WithT(\n  seg: Readonly<[IVec2, IVec2]>,\n  bezier: Readonly<Bezier3>\n): [IVec2, t: number][] {\n  const candidates = getCrossLineAndBezier3WithT(seg, bezier)\n  return candidates.filter(([p]) => isOnSeg(p, seg as unknown as IVec2[]))\n}\n\nexport function getCrossLineAndBezier3(\n  seg: Readonly<[IVec2, IVec2]>,\n  bezier: Readonly<Bezier3>\n): IVec2[] {\n  return getCrossLineAndBezier3WithT(seg, bezier).map(([p]) => p)\n}\n\nexport function getCrossLineAndBezier3WithT(\n  line: Readonly<[IVec2, IVec2]>,\n  bezier: Readonly<Bezier3>\n): [IVec2, t: number][] {\n  const ax = 3 * (bezier[1].x - bezier[2].x) + bezier[3].x - bezier[0].x\n  const ay = 3 * (bezier[1].y - bezier[2].y) + bezier[3].y - bezier[0].y\n\n  const bx = 3 * (bezier[0].x - 2 * bezier[1].x + bezier[2].x)\n  const by = 3 * (bezier[0].y - 2 * bezier[1].y + bezier[2].y)\n\n  const cx = 3 * (bezier[1].x - bezier[0].x)\n  const cy = 3 * (bezier[1].y - bezier[0].y)\n\n  const dx = bezier[0].x\n  const dy = bezier[0].y\n\n  const vx = line[1].y - line[0].y\n  const vy = line[0].x - line[1].x\n\n  const d = line[0].x * vx + line[0].y * vy\n\n  const roots = solveQubicFomula(\n    vx * ax + vy * ay,\n    vx * bx + vy * by,\n    vx * cx + vy * cy,\n    vx * dx + vy * dy - d\n  )\n\n  return roots\n    .filter((t) => 0 <= t && t <= 1)\n    .map((t) => [\n      {\n        x: ((ax * t + bx) * t + cx) * t + dx,\n        y: ((ay * t + by) * t + cy) * t + dy,\n      },\n      t,\n    ])\n}\n\nexport function divideBezier3(\n  bezier: Readonly<Bezier3>,\n  t: number\n): [Bezier3, Bezier3] {\n  const [a, b, c, d] = bezier\n  const e = lerpPoint(a, b, t)\n  const f = lerpPoint(b, c, t)\n  const g = lerpPoint(c, d, t)\n  const h = lerpPoint(e, f, t)\n  const j = lerpPoint(f, g, t)\n  const k = lerpPoint(h, j, t)\n  return [\n    [a, e, h, k],\n    [k, j, g, d],\n  ]\n}\n\nexport function getClosestPointOnBezier3(\n  bezier: Readonly<[c0: IVec2, c1: IVec2, c2: IVec2, c3: IVec2]>,\n  p: Readonly<IVec2>,\n  epsilon: number\n): IVec2 {\n  const lerpFn = getBezier3LerpFn(bezier)\n  const epsilonSq = epsilon * epsilon\n\n  const size = 10\n  let range = [0, 1]\n  let delta = 0\n  let ret = bezier[0]\n  let count = 0\n\n  while (count < 100) {\n    const ranges: number[] = []\n    const rangeSize = range[1] - range[0]\n    const step = rangeSize / size\n    for (let i = 0; i <= size; i++) {\n      ranges.push(range[0] + step * i)\n    }\n\n    let candidate:\n      | [range: [number, number], pedal: IVec2, d: number]\n      | undefined\n    for (let i = 0; i < ranges.length - 1; i++) {\n      const seg = [lerpFn(ranges[i]), lerpFn(ranges[i + 1])]\n      const pedal = getPedal(p, seg)\n      if (isOnSeg(pedal, seg)) {\n        const d = getDistanceSq(p, pedal)\n        if (!candidate || d < candidate[2]) {\n          candidate = [[ranges[i], ranges[i + 1]], pedal, d]\n        }\n      } else {\n        // When the pedal isn't on the segment, either vertex is the closest..\n        const d0 = getDistanceSq(p, seg[0])\n        const d1 = getDistanceSq(p, seg[1])\n        const [d, vertex] = d0 <= d1 ? [d0, seg[0]] : [d1, seg[1]]\n        if (!candidate || d < candidate[2]) {\n          candidate = [[ranges[i], ranges[i + 1]], vertex, d]\n        }\n      }\n    }\n\n    if (!candidate) break\n    if (Math.abs(delta - candidate[2]) < epsilonSq) {\n      ret = candidate[1]\n      break\n    }\n\n    range = candidate[0]\n    delta = candidate[2]\n    count++\n  }\n\n  return ret\n}\n","exports.interopDefault = function (a) {\n  return a && a.__esModule ? a : {default: a};\n};\n\nexports.defineInteropFlag = function (a) {\n  Object.defineProperty(a, '__esModule', {value: true});\n};\n\nexports.exportAll = function (source, dest) {\n  Object.keys(source).forEach(function (key) {\n    if (\n      key === 'default' ||\n      key === '__esModule' ||\n      Object.prototype.hasOwnProperty.call(dest, key)\n    ) {\n      return;\n    }\n\n    Object.defineProperty(dest, key, {\n      enumerable: true,\n      get: function () {\n        return source[key];\n      },\n    });\n  });\n\n  return dest;\n};\n\nexports.export = function (dest, destName, get) {\n  Object.defineProperty(dest, destName, {\n    enumerable: true,\n    get: get,\n  });\n};\n","import { AffineMatrix, ISvgConfigs, ISvgPath, ISvgStyle, IVec2 } from './types'\nimport * as geo from './geo'\n\nconst HTTP_SVG = 'http://www.w3.org/2000/svg'\n// Unary plus operator seems faster than native parseFloat\nconst _parseFloat = (v: string) => +v\n\nexport const configs: ISvgConfigs = {\n  bezierSplitSize: 10,\n  ellipseSplitSize: 20,\n}\n\n/**\n * 描画\n * @param ctx 描画要素\n * @param pathInfo 図形情報\n */\nexport function draw(ctx: CanvasRenderingContext2D, pathInfo: ISvgPath): void {\n  ctx.lineCap = pathInfo.style.lineCap as any\n  ctx.lineJoin = pathInfo.style.lineJoin as any\n\n  ctx.beginPath()\n  pathInfo.d.forEach((p, i) => {\n    if (i === 0) {\n      ctx.moveTo(p.x, p.y)\n    } else {\n      ctx.lineTo(p.x, p.y)\n    }\n  })\n  ctx.closePath()\n\n  if (pathInfo.included) {\n    pathInfo.included.forEach((poly) => {\n      poly.forEach((p, i) => {\n        if (i === 0) {\n          ctx.moveTo(p.x, p.y)\n        } else {\n          ctx.lineTo(p.x, p.y)\n        }\n      })\n      ctx.closePath()\n    })\n  }\n\n  if (pathInfo.style.fill) {\n    ctx.fillStyle = pathInfo.style.fillStyle\n    ctx.globalAlpha = pathInfo.style.fillGlobalAlpha\n    ctx.fill()\n  }\n\n  // 枠\n  if (pathInfo.style.stroke) {\n    ctx.strokeStyle = pathInfo.style.strokeStyle\n    ctx.globalAlpha = pathInfo.style.strokeGlobalAlpha\n    ctx.lineWidth = pathInfo.style.lineWidth\n    ctx.setLineDash(pathInfo.style.lineDash)\n    ctx.stroke()\n  }\n  ctx.globalAlpha = 1\n}\n\n/**\n * 矩形に収まるよう調整\n * @param pathInfoList パス情報リスト\n * @param x 矩形x座標\n * @param y 矩形y座標\n * @param width 矩形width\n * @param height 矩形height\n * @return 調整後パス情報リスト\n */\nexport function fitRect(\n  pathInfoList: ISvgPath[],\n  x: number,\n  y: number,\n  width: number,\n  height: number\n): ISvgPath[] {\n  let minX: number = Infinity\n  let maxX: number = -Infinity\n  let minY: number = Infinity\n  let maxY: number = -Infinity\n  pathInfoList.forEach((info) => {\n    info.d.forEach((p) => {\n      minX = Math.min(minX, p.x)\n      maxX = Math.max(maxX, p.x)\n      minY = Math.min(minY, p.y)\n      maxY = Math.max(maxY, p.y)\n    })\n  })\n\n  // 原点基準に移動\n  const fromBaseList = pathInfoList.map((info) => ({\n    ...info,\n    d: info.d.map((p) => geo.vec(p.x - minX, p.y - minY)),\n  }))\n  // 伸縮\n  const orgWidth = maxX - minX\n  const orgHeight = maxY - minY\n  const rateX = width / orgWidth\n  const rateY = height / orgHeight\n  const rate = Math.min(rateX, rateY)\n  const scaledList = fromBaseList.map((info) => ({\n    ...info,\n    d: info.d.map((p) => geo.vec(p.x * rate, p.y * rate)),\n  }))\n  // 矩形位置に移動\n  const difX = x + (width - orgWidth * rate) / 2\n  const difY = y + (height - orgHeight * rate) / 2\n  const convertedList: ISvgPath[] = scaledList.map((info) => ({\n    ...info,\n    d: info.d.map((p) => geo.vec(p.x + difX, p.y + difY)),\n    included: (info.included || []).map((poly: IVec2[]) => {\n      return poly.map((p) =>\n        geo.vec((p.x - minX) * rate + difX, (p.y - minY) * rate + difY)\n      )\n    }),\n  }))\n\n  return convertedList\n}\n\n/**\n * SVG文字列から図形のパス情報を取得する\n * 対応タグ: path,rect,ellipse,circle\n * @param svgString SVGリソース文字列\n * @return パス情報リスト\n */\nexport function parseSvgGraphicsStr(svgString: string): ISvgPath[] {\n  const domParser = new DOMParser()\n  const svgDom = domParser.parseFromString(svgString, 'image/svg+xml')\n  const svgTags = svgDom.getElementsByTagName('svg')\n  if (!svgTags || svgTags.length === 0) return []\n  return parseSvgGraphics(svgTags[0] as SVGElement)\n}\n\n/**\n * parse SVG tree\n * @param elm SVGElement\n * @return path informations\n */\nfunction parseSvgTree(\n  elm: SVGElement,\n  parentInfo?: { style?: ISvgStyle; transform?: AffineMatrix }\n): ISvgPath[] {\n  const style = { ...(parentInfo?.style ?? {}), ...parseTagStyle(elm) }\n\n  const transformStr = elm.getAttribute('transform')\n  const parentTransform = parentInfo?.transform ?? geo.IDENTITY_AFFINE\n\n  let ret: ISvgPath[] = []\n\n  const svgPath = parseSVGShape(elm)\n  if (svgPath) {\n    ret.push({\n      ...svgPath,\n      d: svgPath.d.map((v) => geo.applyAffine(parentTransform, v)),\n    })\n  }\n\n  if (elm.children.length > 0) {\n    const transform = transformStr\n      ? geo.multiAffine(parentTransform, parseTransform(transformStr))\n      : parentTransform\n\n    Array.from(elm.children).forEach((child) => {\n      ret = ret.concat(parseSvgTree(child as SVGElement, { style, transform }))\n    })\n  }\n\n  return ret\n}\n\nfunction parseSVGShape(elm: SVGElement): ISvgPath | undefined {\n  switch (elm.tagName.toLowerCase()) {\n    case 'path':\n      return {\n        d: parsePath(elm as SVGPathElement),\n        style: parseTagStyle(elm),\n      }\n    case 'rect':\n      return {\n        d: parseRect(elm as SVGRectElement),\n        style: parseTagStyle(elm),\n      }\n    case 'ellipse':\n      return {\n        d: parseEllipse(elm as SVGEllipseElement),\n        style: parseTagStyle(elm),\n      }\n    case 'circle':\n      return {\n        d: parseCircle(elm as SVGCircleElement),\n        style: parseTagStyle(elm),\n      }\n    default:\n      return undefined\n  }\n}\n\n/**\n * SVGタグから図形のパス情報を取得する\n * 対応タグ: path,rect,ellipse,circle\n * @param svgTag SVGタグ\n * @return パス情報リスト\n */\nexport function parseSvgGraphics(svgTag: SVGElement): ISvgPath[] {\n  return parseSvgTree(svgTag)\n}\n\n/**\n * opentype.jsのpath.commandをd文字列に変換する\n * @param fontPath opentype.jsのpath.command\n * @return d文字列\n */\nexport function openCommandToD(command: any): string {\n  let d: string = command.type\n  if ('x1' in command) d += ` ${command.x1}`\n  if ('y1' in command) d += ` ${command.y1}`\n  if ('x2' in command) d += ` ${command.x2}`\n  if ('y2' in command) d += ` ${command.y2}`\n  if ('x3' in command) d += ` ${command.x3}`\n  if ('y3' in command) d += ` ${command.y3}`\n  if ('x' in command) d += ` ${command.x}`\n  if ('y' in command) d += ` ${command.y}`\n  return d\n}\n\n/**\n * opentype.jsのpathを解析する\n * @param fontPath opentype.jsのpath\n * @return パス情報リスト\n */\nexport function parseOpenPath(fontPath: { commands: any[] }): ISvgPath[] {\n  const pathInfoList: ISvgPath[] = []\n  let current: string = ''\n  fontPath.commands.forEach((c: any) => {\n    current += openCommandToD(c) + ' '\n    if (current && c.type.toUpperCase() === 'Z') {\n      const pathList = parsePathD(current)\n      pathInfoList.push({\n        d: pathList,\n        style: {\n          ...createStyle(),\n          fill: true,\n          fillStyle: 'black',\n          stroke: false,\n        },\n      })\n      current = ''\n    }\n  })\n  return pathInfoList\n}\n\nexport type PathSegmentRaw =\n  | ['Z' | 'z']\n  | ['H' | 'h' | 'V' | 'v', number]\n  | ['M' | 'm' | 'L' | 'l' | 'T' | 't', number, number]\n  | ['Q' | 'q' | 'S' | 's', number, number, number, number]\n  | ['C' | 'c', number, number, number, number, number, number]\n  | ['A' | 'a', number, number, number, boolean, boolean, number, number]\n\nfunction parsePathSegmentRaw(segment: string[]): PathSegmentRaw {\n  if (segment.length === 8) {\n    return [\n      segment[0],\n      _parseFloat(segment[1]),\n      _parseFloat(segment[2]),\n      _parseFloat(segment[3]),\n      segment[4] !== '0',\n      segment[5] !== '0',\n      _parseFloat(segment[6]),\n      _parseFloat(segment[7]),\n    ] as PathSegmentRaw\n  } else {\n    const [c, ...values] = segment\n    return [c, ...values.map(_parseFloat)] as PathSegmentRaw\n  }\n}\n\nexport function parsePathSegmentRaws(dStr: string): PathSegmentRaw[] {\n  return splitD(dStr).map((c) => parsePathSegmentRaw(c))\n}\n\nexport function pathSegmentRawsToString(segs: PathSegmentRaw[]): string {\n  return segs.map(pathSegmentRawToString).join(' ')\n}\n\nexport function pathSegmentRawToString(seg: PathSegmentRaw): string {\n  return seg\n    .map((v) => {\n      if (v === true) {\n        return '1'\n      } else if (v === false) {\n        return '0'\n      } else {\n        return v.toString()\n      }\n    })\n    .join(' ')\n}\n\ntype PathSegment =\n  | {\n      command: string\n      lerpFn: (t: number) => IVec2\n      curve: true\n    }\n  | {\n      command: string\n      segment: [IVec2, IVec2]\n      curve?: undefined\n    }\n\nexport function parsePathSegments(dStr: string): PathSegment[] {\n  return _parsePathSegments(parsePathSegmentRaws(dStr))\n}\n\nfunction _parsePathSegments(segments: PathSegmentRaw[]): PathSegment[] {\n  const ret: PathSegment[] = []\n  let startP = geo.vec(0, 0)\n  let currentP = startP\n  let currentControlP = startP\n  let currentBezier: 1 | 2 | 3 = 1\n  segments.forEach((current) => {\n    switch (current[0]) {\n      case 'M': {\n        const p1 = geo.vec(current[1], current[2])\n        ret.push({ command: 'M', segment: [p1, p1] })\n        startP = p1\n        currentControlP = p1\n        currentBezier = 1\n        currentP = p1\n        break\n      }\n      case 'm': {\n        const p1 = geo.vec(current[1], current[2])\n        ret.push({ command: 'm', segment: [p1, p1] })\n        startP = p1\n        currentP = p1\n        currentControlP = p1\n        currentBezier = 1\n        break\n      }\n      case 'L': {\n        const p0 = currentP\n        const p1 = geo.vec(current[1], current[2])\n        ret.push({ command: 'L', segment: [p0, p1] })\n        startP ??= p1\n        currentControlP = p1\n        currentBezier = 1\n        currentP = p1\n        break\n      }\n      case 'l': {\n        const p0 = currentP\n        const p1 = geo.add(currentP, geo.vec(current[1], current[2]))\n        ret.push({ command: 'l', segment: [p0, p1] })\n        startP ??= p1\n        currentControlP = p1\n        currentBezier = 1\n        currentP = p1\n        break\n      }\n      case 'H': {\n        const p0 = currentP\n        const p1 = geo.vec(current[1], p0.y)\n        ret.push({ command: 'H', segment: [p0, p1] })\n        currentControlP = p1\n        currentBezier = 1\n        currentP = p1\n        break\n      }\n      case 'h': {\n        const p0 = currentP\n        const p1 = geo.vec(current[1] + p0.x, p0.y)\n        ret.push({ command: 'h', segment: [p0, p1] })\n        currentControlP = p1\n        currentBezier = 1\n        currentP = p1\n        break\n      }\n      case 'V': {\n        const p0 = currentP\n        const p1 = geo.vec(p0.x, current[1])\n        ret.push({ command: 'V', segment: [p0, p1] })\n        currentControlP = p1\n        currentBezier = 1\n        currentP = p1\n        break\n      }\n      case 'v': {\n        const p0 = currentP\n        const p1 = geo.vec(p0.x, current[1] + p0.y)\n        ret.push({ command: 'v', segment: [p0, p1] })\n        currentControlP = p1\n        currentBezier = 1\n        currentP = p1\n        break\n      }\n      case 'Q': {\n        const p0 = currentP\n        const p1 = geo.vec(current[1], current[2])\n        const p2 = geo.vec(current[3], current[4])\n        ret.push({\n          command: 'Q',\n          lerpFn: geo.getBezier2LerpFn([p0, p1, p2]),\n          curve: true,\n        })\n        currentControlP = p1\n        currentBezier = 2\n        currentP = p2\n        break\n      }\n      case 'q': {\n        const p0 = currentP\n        const p1 = geo.add(p0, geo.vec(current[1], current[2]))\n        const p2 = geo.add(p0, geo.vec(current[3], current[4]))\n        ret.push({\n          command: 'q',\n          lerpFn: geo.getBezier2LerpFn([p0, p1, p2]),\n          curve: true,\n        })\n        currentControlP = p1\n        currentBezier = 2\n        currentP = p2\n        break\n      }\n      case 'T': {\n        const p0 = currentP\n        const p1 =\n          currentBezier === 2 ? geo.getSymmetry(currentControlP, p0) : p0\n        const p2 = geo.vec(current[1], current[2])\n        ret.push({\n          command: 'T',\n          lerpFn: geo.getBezier2LerpFn([p0, p1, p2]),\n          curve: true,\n        })\n        currentControlP = p1\n        currentBezier = 2\n        currentP = p2\n        break\n      }\n      case 't': {\n        const p0 = currentP\n        const p1 =\n          currentBezier === 2 ? geo.getSymmetry(currentControlP, p0) : p0\n        const p2 = geo.add(p0, geo.vec(current[1], current[2]))\n        ret.push({\n          command: 't',\n          lerpFn: geo.getBezier2LerpFn([p0, p1, p2]),\n          curve: true,\n        })\n        currentControlP = p1\n        currentBezier = 2\n        currentP = p2\n        break\n      }\n      case 'C': {\n        const p0 = currentP\n        const p1 = geo.vec(current[1], current[2])\n        const p2 = geo.vec(current[3], current[4])\n        const p3 = geo.vec(current[5], current[6])\n        ret.push({\n          command: 'C',\n          lerpFn: geo.getBezier3LerpFn([p0, p1, p2, p3]),\n          curve: true,\n        })\n        currentControlP = p2\n        currentBezier = 3\n        currentP = p3\n        break\n      }\n      case 'c': {\n        const p0 = currentP\n        const p1 = geo.add(p0, geo.vec(current[1], current[2]))\n        const p2 = geo.add(p0, geo.vec(current[3], current[4]))\n        const p3 = geo.add(p0, geo.vec(current[5], current[6]))\n        ret.push({\n          command: 'c',\n          lerpFn: geo.getBezier3LerpFn([p0, p1, p2, p3]),\n          curve: true,\n        })\n        currentControlP = p2\n        currentBezier = 3\n        currentP = p3\n        break\n      }\n      case 'S': {\n        const p0 = currentP\n        const p1 =\n          currentBezier === 3 ? geo.getSymmetry(currentControlP, p0) : p0\n        const p2 = geo.vec(current[1], current[2])\n        const p3 = geo.vec(current[3], current[4])\n        ret.push({\n          command: 'S',\n          lerpFn: geo.getBezier3LerpFn([p0, p1, p2, p3]),\n          curve: true,\n        })\n        currentControlP = p2\n        currentBezier = 3\n        currentP = p3\n        break\n      }\n      case 's': {\n        const p0 = currentP\n        const p1 =\n          currentBezier === 3 ? geo.getSymmetry(currentControlP, p0) : p0\n        const p2 = geo.add(p0, geo.vec(current[1], current[2]))\n        const p3 = geo.add(p0, geo.vec(current[3], current[4]))\n        ret.push({\n          command: 's',\n          lerpFn: geo.getBezier3LerpFn([p0, p1, p2, p3]),\n          curve: true,\n        })\n        currentControlP = p2\n        currentBezier = 3\n        currentP = p3\n        break\n      }\n      case 'A': {\n        const p0 = currentP\n        const rx = current[1]\n        const ry = current[2]\n        const large = current[4]\n        const sweep = current[5]\n        const radian = (current[3] / 180) * Math.PI\n        const p1 = geo.vec(current[6], current[7])\n        ret.push({\n          command: 'A',\n          lerpFn: geo.getArcLerpFn(rx, ry, p0, p1, large, sweep, radian),\n          curve: true,\n        })\n        currentControlP = p1\n        currentBezier = 1\n        currentP = p1\n        break\n      }\n      case 'a': {\n        const p0 = currentP\n        const rx = current[1]\n        const ry = current[2]\n        const large = current[4]\n        const sweep = current[5]\n        const radian = (current[3] / 180) * Math.PI\n        const p1 = geo.add(p0, geo.vec(current[6], current[7]))\n        ret.push({\n          command: 'a',\n          lerpFn: geo.getArcLerpFn(rx, ry, p0, p1, large, sweep, radian),\n          curve: true,\n        })\n        currentControlP = p1\n        currentBezier = 1\n        currentP = p1\n        break\n      }\n      case 'Z':\n      case 'z': {\n        const p0 = currentP\n        const p1 = startP\n        ret.push({\n          command: current[0],\n          segment: [p0, p1],\n        })\n        currentControlP = p1\n        currentBezier = 1\n        currentP = p1\n        break\n      }\n    }\n  })\n\n  return ret\n}\n\nexport interface PathLengthStruct {\n  lerpFn: (t: number) => IVec2\n  length: number\n  curve?: boolean\n}\n\nexport function getPathLengthStructs(\n  dStr: string,\n  split = configs.bezierSplitSize\n): PathLengthStruct[] {\n  return parsePathSegments(dStr).map((seg) => ({\n    lerpFn: seg.curve\n      ? seg.lerpFn\n      : (t) => geo.lerpPoint(seg.segment[0], seg.segment[1], t),\n    length: geo.getPolylineLength(\n      seg.curve ? geo.getApproPoints(seg.lerpFn, split) : seg.segment\n    ),\n    curve: seg.curve,\n  }))\n}\n\n/**\n * Execute \"getPathTotalLength\" with cacheable structs generated by \"getPathLengthStructs\"\n */\nexport function getPathTotalLengthFromStructs(\n  structs: PathLengthStruct[]\n): number {\n  return structs.reduce((p, s) => p + s.length, 0)\n}\n\n/**\n * Alternative function of \"SVGGeometryElement.getTotalLength\"\n * @param dStr d string of path element\n * @param split the number of segments to approximate a curve\n * @return total length of the path\n */\nexport function getPathTotalLength(\n  dStr: string,\n  split = configs.bezierSplitSize\n): number {\n  return getPathTotalLengthFromStructs(getPathLengthStructs(dStr, split))\n}\n\n/**\n * Execute \"getPathPointAtLength\" with cacheable structs generated by \"getPathLengthStructs\"\n */\nexport function getPathPointAtLengthFromStructs(\n  structs: PathLengthStruct[],\n  distance: number,\n  split = configs.bezierSplitSize\n): IVec2 {\n  if (structs.length === 0) return geo.vec(0, 0)\n  if (distance === 0) {\n    return structs[0].lerpFn(0)\n  }\n\n  let l = Math.max(distance, 0)\n  for (let i = 0; i < structs.length; i++) {\n    const s = structs[i]\n    if (l < s.length) {\n      return s.curve\n        ? seekDistantPointOfLerpFn(s, l, split)\n        : s.lerpFn(l / s.length)\n    } else if (l === s.length) {\n      return s.lerpFn(1)\n    } else {\n      l -= s.length\n    }\n  }\n  return structs[structs.length - 1].lerpFn(1)\n}\n\nfunction seekDistantPointOfLerpFn(\n  pathStruct: PathLengthStruct,\n  distant: number,\n  split = configs.bezierSplitSize\n): IVec2 {\n  const step = 1 / split\n  let prev = pathStruct.lerpFn(0)\n  let sum = 0\n  for (let i = 1; i <= split; i++) {\n    const t = step * i\n    const p = pathStruct.lerpFn(t)\n    const d = geo.getDistance(prev, p)\n    const nextSum = sum + d\n    if (Math.abs(distant - nextSum) < geo.MINVALUE) {\n      return p\n    } else if (distant < nextSum) {\n      return pathStruct.lerpFn(t - ((nextSum - distant) / d) * step)\n    }\n\n    prev = p\n    sum = nextSum\n  }\n\n  return pathStruct.lerpFn(1)\n}\n\n/**\n * Alternative function of \"SVGGeometryElement.getPointAtLength\"\n * @param dStr d string of path element\n * @param distance target length\n * @param split the number of segments to approximate a curve\n * @return the point at the target length\n */\nexport function getPathPointAtLength(\n  dStr: string,\n  distance: number,\n  split = configs.bezierSplitSize\n): IVec2 {\n  return getPathPointAtLengthFromStructs(\n    getPathLengthStructs(dStr, split),\n    distance,\n    split\n  )\n}\n\nfunction getPathAbsPoints(segments: PathSegmentRaw[]): {\n  controls: IVec2[]\n  points: IVec2[]\n} {\n  const points: IVec2[] = []\n  const controls: IVec2[] = []\n\n  let seg: PathSegmentRaw\n  let startP = geo.vec(0, 0)\n  let absP = startP\n  let preC = startP\n  let preCType: 1 | 2 | 3 = 1\n  for (let i = 0; i < segments.length; i++) {\n    seg = segments[i]\n    switch (seg[0]) {\n      case 'M': {\n        const p = geo.vec(seg[1], seg[2])\n        startP = absP = preC = p\n        preCType = 1\n        break\n      }\n      case 'm': {\n        const p = geo.add(geo.vec(seg[1], seg[2]), absP)\n        startP = absP = preC = p\n        preCType = 1\n        break\n      }\n      case 'L': {\n        const p = geo.vec(seg[1], seg[2])\n        startP ??= p\n        absP = preC = p\n        preCType = 1\n        break\n      }\n      case 'l': {\n        const p = geo.add(geo.vec(seg[1], seg[2]), absP)\n        startP ??= p\n        absP = preC = p\n        preCType = 1\n        break\n      }\n      case 'H': {\n        const p = geo.vec(seg[1], absP.y)\n        absP = preC = p\n        preCType = 1\n        break\n      }\n      case 'h': {\n        const p = geo.vec(seg[1] + absP.x, absP.y)\n        absP = preC = p\n        preCType = 1\n        break\n      }\n      case 'V': {\n        const p = geo.vec(absP.x, seg[1])\n        absP = preC = p\n        preCType = 1\n        break\n      }\n      case 'v': {\n        const p = geo.vec(absP.x, seg[1] + absP.y)\n        absP = preC = p\n        preCType = 1\n        break\n      }\n      case 'Q': {\n        const p = geo.vec(seg[1], seg[2])\n        preC = p\n        absP = geo.vec(seg[3], seg[4])\n        preCType = 2\n        break\n      }\n      case 'q': {\n        const p = geo.vec(seg[1] + absP.x, seg[2] + absP.y)\n        preC = p\n        absP = geo.vec(seg[3] + absP.x, seg[4] + absP.y)\n        preCType = 2\n        break\n      }\n      case 'T': {\n        const p = preCType === 2 ? geo.lerpPoint(preC, absP, 2) : absP\n        preC = p\n        absP = geo.vec(seg[1], seg[2])\n        preCType = 2\n        break\n      }\n      case 't': {\n        const p = preCType === 2 ? geo.lerpPoint(preC, absP, 2) : absP\n        preC = p\n        absP = geo.vec(seg[1] + absP.x, seg[2] + absP.y)\n        preCType = 2\n        break\n      }\n      case 'C': {\n        const p = geo.vec(seg[3], seg[4])\n        preC = p\n        absP = geo.vec(seg[5], seg[6])\n        preCType = 3\n        break\n      }\n      case 'c': {\n        const p = geo.vec(seg[3] + absP.x, seg[4] + absP.y)\n        preC = p\n        absP = geo.vec(seg[5] + absP.x, seg[6] + absP.y)\n        preCType = 3\n        break\n      }\n      case 'S': {\n        const p = preCType === 3 ? geo.lerpPoint(preC, absP, 2) : absP\n        preC = p\n        absP = geo.vec(seg[3], seg[4])\n        preCType = 3\n        break\n      }\n      case 's': {\n        const p = preCType === 3 ? geo.lerpPoint(preC, absP, 2) : absP\n        preC = p\n        absP = geo.vec(seg[3] + absP.x, seg[4] + absP.y)\n        preCType = 3\n        break\n      }\n      case 'A': {\n        const p = geo.vec(seg[6], seg[7])\n        absP = preC = p\n        preCType = 1\n        break\n      }\n      case 'a': {\n        const p = geo.vec(seg[6] + absP.x, seg[7] + absP.y)\n        absP = preC = p\n        preCType = 1\n        break\n      }\n      case 'Z':\n      case 'z': {\n        absP = preC = startP\n        preCType = 1\n        break\n      }\n      default:\n        throw getUnknownError()\n    }\n\n    controls.push(preC)\n    points.push(absP)\n  }\n\n  return { points, controls }\n}\n\nfunction isCurveCommand(c: string) {\n  return /Q|q|T|t|C|c|S|s|A|a/.test(c)\n}\n\n/**\n * The first segment has to be either \"M\", \"m\", \"L\" or \"l\".\n *\n * The last segment will be converted to normalized value.\n * e.g. [m, l, v, z] => [M, v, l, z]\n *\n * \"T\", \"t\", \"S\" or \"s\" will be converted to \"Q\", \"q\", \"C\" or \"c\"\n */\nexport function reversePath(segments: PathSegmentRaw[]): PathSegmentRaw[] {\n  if (segments.length < 2) return segments\n\n  const ret: PathSegmentRaw[] = []\n\n  const { points: absPoints, controls: absContolPoints } =\n    getPathAbsPoints(segments)\n\n  const length = segments.length\n  let current: PathSegmentRaw\n  let absP: IVec2\n  let closeCount = false\n  for (let i = length - 1; 0 <= i; i--) {\n    current = segments[i]\n    absP = absPoints[i === 0 ? length - 1 : i - 1]\n\n    switch (current[0]) {\n      case 'M':\n        if (closeCount) {\n          if (isCurveCommand(ret[ret.length - 1][0])) {\n            ret.push(['Z'])\n          } else {\n            ret[ret.length - 1] = ['Z']\n          }\n          closeCount = false\n        }\n        ret.push([current[0], absP.x, absP.y])\n        break\n      case 'm':\n        if (closeCount) {\n          if (isCurveCommand(ret[ret.length - 1][0])) {\n            ret.push(['z'])\n          } else {\n            ret[ret.length - 1] = ['z']\n          }\n          closeCount = false\n        }\n        if (i === 0) {\n          ret.push(['M', absP.x, absP.y])\n        } else {\n          ret.push([current[0], -current[1], -current[2]])\n        }\n        break\n      case 'L':\n        if (closeCount && i === 0) {\n          if (isCurveCommand(ret[ret.length - 1][0])) {\n            ret.push(['Z'])\n          } else {\n            ret[ret.length - 1] = ['Z']\n          }\n          closeCount = false\n        }\n        ret.push([current[0], absP.x, absP.y])\n        break\n      case 'l':\n        if (closeCount && i === 0) {\n          if (isCurveCommand(ret[ret.length - 1][0])) {\n            ret.push(['z'])\n          } else {\n            ret[ret.length - 1] = ['z']\n          }\n          closeCount = false\n        }\n        if (i === 0) {\n          ret.push(['L', absP.x, absP.y])\n        } else {\n          ret.push([current[0], -current[1], -current[2]])\n        }\n        break\n      case 'H':\n        ret.push([current[0], absP.x])\n        break\n      case 'h':\n        ret.push([current[0], -current[1]])\n        break\n      case 'V':\n        ret.push([current[0], absP.y])\n        break\n      case 'v':\n        ret.push([current[0], -current[1]])\n        break\n      case 'Q': {\n        ret.push([current[0], current[1], current[2], absP.x, absP.y])\n        break\n      }\n      case 'q': {\n        ret.push([\n          current[0],\n          current[1] - current[3],\n          current[2] - current[4],\n          -current[3],\n          -current[4],\n        ])\n        break\n      }\n      case 'T': {\n        const c = absContolPoints[i]\n        ret.push(['Q', c.x, c.y, absP.x, absP.y])\n        break\n      }\n      case 't': {\n        const b = absPoints[i]\n        const c = absContolPoints[i]\n        ret.push(['q', c.x - b.x, c.y - b.y, -current[1], -current[2]])\n        break\n      }\n      case 'C': {\n        ret.push([\n          current[0],\n          current[3],\n          current[4],\n          current[1],\n          current[2],\n          absP.x,\n          absP.y,\n        ])\n        break\n      }\n      case 'c': {\n        ret.push([\n          current[0],\n          current[3] - current[5],\n          current[4] - current[6],\n          current[1] - current[5],\n          current[2] - current[6],\n          -current[5],\n          -current[6],\n        ])\n        break\n      }\n      case 'S': {\n        const c = absContolPoints[i]\n        ret.push(['C', current[1], current[2], c.x, c.y, absP.x, absP.y])\n        break\n      }\n      case 's': {\n        const b = absPoints[i]\n        const c = absContolPoints[i]\n        ret.push([\n          'c',\n          current[1] - current[3],\n          current[2] - current[4],\n          c.x - b.x,\n          c.y - b.y,\n          -current[3],\n          -current[4],\n        ])\n        break\n      }\n      case 'A': {\n        ret.push([\n          current[0],\n          current[1],\n          current[2],\n          current[3],\n          current[4],\n          !current[5],\n          absP.x,\n          absP.y,\n        ])\n        break\n      }\n      case 'a': {\n        ret.push([\n          current[0],\n          current[1],\n          current[2],\n          current[3],\n          current[4],\n          !current[5],\n          -current[6],\n          -current[7],\n        ])\n        break\n      }\n      case 'Z':\n        closeCount = true\n        ret.push(['L', absP.x, absP.y])\n        break\n      case 'z': {\n        closeCount = true\n        const absPP = absPoints[i]\n        ret.push(['l', absP.x - absPP.x, absP.y - absPP.y])\n        break\n      }\n    }\n  }\n\n  ret.unshift(ret.pop()!)\n\n  return ret\n}\n\n/**\n * Slide segments.\n * Relative segments will not be slided by this function.\n */\nexport function slidePath(\n  segments: PathSegmentRaw[],\n  diff: IVec2\n): PathSegmentRaw[] {\n  return segments.map((current) => {\n    const slided: PathSegmentRaw = [...current]\n    switch (slided[0]) {\n      case 'H':\n        slided[1] += diff.x\n        break\n      case 'V':\n        slided[1] += diff.y\n        break\n      case 'A':\n        slided[6] += diff.x\n        slided[7] += diff.y\n        break\n      default:\n        if (slided[0] === slided[0].toUpperCase()) {\n          for (let i = 1; i < slided.length - 1; i += 2) {\n            ;(slided[i] as number) += diff.x\n            ;(slided[i + 1] as number) += diff.y\n          }\n        }\n        break\n    }\n    return slided\n  })\n}\n\n/**\n * Scale segments.\n * Both abstract and relative segments will be scaled by this function.\n */\nexport function scalePath(\n  segments: PathSegmentRaw[],\n  scale: IVec2\n): PathSegmentRaw[] {\n  return segments.map((current) => {\n    const slided: PathSegmentRaw = [...current]\n    switch (slided[0]) {\n      case 'H':\n      case 'h':\n        slided[1] *= scale.x\n        break\n      case 'V':\n      case 'v':\n        slided[1] *= scale.y\n        break\n      case 'A':\n      case 'a':\n        slided[1] *= Math.abs(scale.x)\n        slided[2] *= Math.abs(scale.y)\n        if (scale.x * scale.y < 0) {\n          slided[5] = !slided[5]\n        }\n        slided[6] *= scale.x\n        slided[7] *= scale.y\n        break\n      default:\n        for (let i = 1; i < slided.length - 1; i += 2) {\n          ;(slided[i] as number) *= scale.x\n          ;(slided[i + 1] as number) *= scale.y\n        }\n        break\n    }\n    return slided\n  })\n}\n\nfunction convertHVToL(segments: PathSegmentRaw[]): PathSegmentRaw[] {\n  // If neither \"H\" nor \"V\" exists, abstract points doesn't have to be computed.\n  const absVHExisted = segments.some((s) => /H|V/.test(s[0]))\n  const { points } = getPathAbsPoints(absVHExisted ? segments : [])\n\n  return segments.map((s, i) => {\n    switch (s[0]) {\n      case 'H':\n        return ['L', s[1], points[i].y]\n      case 'h':\n        return ['l', s[1], 0]\n      case 'V':\n        return ['L', points[i].x, s[1]]\n      case 'v':\n        return ['l', 0, s[1]]\n      default:\n        return s\n    }\n  })\n}\n\n/**\n * Rotate segments.\n * Both abstract and relative segments will be rotated by this function.\n * \"H\", \"h\", \"V\" and \"v\" will be converted to \"L\" or \"l\"\n */\nexport function rotatePath(\n  segments: PathSegmentRaw[],\n  radian: number\n): PathSegmentRaw[] {\n  const sin = Math.sin(radian)\n  const cos = Math.cos(radian)\n  return convertHVToL(segments).map((current) => {\n    const slided: PathSegmentRaw = [...current]\n    switch (slided[0]) {\n      case 'A':\n      case 'a': {\n        slided[3] += (radian * 180) / Math.PI\n        const x = slided[6]\n        const y = slided[7]\n        slided[6] = cos * x - sin * y\n        slided[7] = sin * x + cos * y\n        break\n      }\n      default:\n        for (let i = 1; i < slided.length - 1; i += 2) {\n          const x = slided[i] as number\n          const y = slided[i + 1] as number\n          ;(slided[i] as number) = cos * x - sin * y\n          ;(slided[i + 1] as number) = sin * x + cos * y\n        }\n        break\n    }\n    return slided\n  })\n}\n\n/**\n * Parse path d string and approximate it as a polyline\n * Note:\n * - Jump information by M/m commands doesn't remain in a polyline\n * - Z/z commands are ignored => The tail point doesn't become the same as the head one by these commands\n * @param dStr d string of path element\n * @return approximated polyline\n */\nexport function parsePathD(\n  dStr: string,\n  split = configs.bezierSplitSize\n): IVec2[] {\n  const _split = Math.max(1, split)\n  let ret: IVec2[] = []\n  let step = 1 / _split\n  parsePathSegments(dStr).forEach((seg) => {\n    if (seg.command === 'Z' || seg.command === 'z') return\n\n    if (seg.curve) {\n      for (let i = 1; i <= _split; i++) {\n        ret.push(seg.lerpFn(step * i))\n      }\n    } else {\n      ret.push(seg.segment[1])\n    }\n  })\n  return ret\n}\n\n/**\n * pathタグを解析する\n * @param svgPath SVGのpathタグDOM\n * @return 座標リスト\n */\nexport function parsePath(svgPath: SVGPathElement): IVec2[] {\n  const dStr = svgPath.getAttribute('d')\n  return dStr\n    ? adoptTransform(svgPath.getAttribute('transform'), parsePathD(dStr))\n    : []\n}\n\n/**\n * rectタグを解析する\n * @param SVGのrectタグDOM\n * @return 座標リスト\n */\nexport function parseRect(svgRect: SVGRectElement): IVec2[] {\n  const x = _parseFloat(svgRect.getAttribute('x') || '0')\n  const y = _parseFloat(svgRect.getAttribute('y') || '0')\n  const width = _parseFloat(svgRect.getAttribute('width') || '0')\n  const height = _parseFloat(svgRect.getAttribute('height') || '0')\n\n  // トランスフォーム\n  return adoptTransform(svgRect.getAttribute('transform'), [\n    geo.vec(x, y),\n    geo.vec(x + width, y),\n    geo.vec(x + width, y + height),\n    geo.vec(x, y + height),\n  ])\n}\n\n/**\n * ellipseタグを解析する\n * @param svgEllipse SVGのellipseタグDOM\n * @return 座標リスト\n */\nexport function parseEllipse(svgEllipse: SVGEllipseElement): IVec2[] {\n  const cx = _parseFloat(svgEllipse.getAttribute('cx') || '0')\n  const cy = _parseFloat(svgEllipse.getAttribute('cy') || '0')\n  const rx = _parseFloat(svgEllipse.getAttribute('rx') || '1')\n  const ry = _parseFloat(svgEllipse.getAttribute('ry') || '1')\n\n  // トランスフォーム\n  return adoptTransform(\n    svgEllipse.getAttribute('transform'),\n    geo.approximateArc(\n      rx,\n      ry,\n      0,\n      Math.PI * 2,\n      geo.vec(cx, cy),\n      0,\n      configs.ellipseSplitSize\n    )\n  )\n}\n\n/**\n * circleタグを解析する\n * @param svgCircle  SVGのcircleタグDOM\n * @return 座標リスト\n */\nexport function parseCircle(svgCircle: SVGCircleElement): IVec2[] {\n  const cx = _parseFloat(svgCircle.getAttribute('cx') || '0')\n  const cy = _parseFloat(svgCircle.getAttribute('cy') || '0')\n  const r = _parseFloat(svgCircle.getAttribute('r') || '1')\n\n  // トランスフォーム\n  return adoptTransform(\n    svgCircle.getAttribute('transform'),\n    geo.approximateArc(\n      r,\n      r,\n      0,\n      Math.PI * 2,\n      geo.vec(cx, cy),\n      0,\n      configs.ellipseSplitSize\n    )\n  )\n}\n\n/**\n * transformを行う\n * @param commandStr コマンド文字列\n * @param points 変換前座標リスト\n * @return 変形後座標リスト\n */\nexport function adoptTransform(\n  commandStr: string | null,\n  points: IVec2[]\n): IVec2[] {\n  if (!commandStr) return points\n\n  let ret: IVec2[] = geo.cloneVectors(points)\n  // 複数コマンドの場合もあるのでループ\n  const commandList = commandStr.split(/\\)/)\n  commandList.forEach((current) => {\n    const tmp = current.split(/\\(/)\n    if (tmp.length === 2) {\n      const command = tmp[0].trim().toLowerCase()\n      const params = parseNumbers(tmp[1])\n\n      switch (command) {\n        case 'matrix': {\n          ret = geo.transform(ret, params)\n          break\n        }\n        case 'translate': {\n          ret = ret.map((p) => geo.vec(p.x + params[0], p.y + params[1]))\n          break\n        }\n        case 'scale': {\n          const scaleX = params[0]\n          // XY等倍の場合を考慮\n          let scaleY = params[0]\n          if (params.length > 1) {\n            scaleY = params[1]\n          }\n          ret = ret.map((p) => geo.vec(p.x * scaleX, p.y * scaleY))\n          break\n        }\n        case 'rotate': {\n          // 回転基準点\n          let base: IVec2 = geo.vec(0, 0)\n          if (params.length > 2) {\n            base = geo.vec(params[1], params[2])\n          }\n          ret = ret.map((p) => geo.rotate(p, (params[0] * Math.PI) / 180, base))\n          break\n        }\n        case 'skewx': {\n          ret = ret.map((p) =>\n            geo.vec(p.x + Math.tan((params[0] * Math.PI) / 180) * p.y, p.y)\n          )\n          break\n        }\n        case 'skewy': {\n          ret = ret.map((p) =>\n            geo.vec(p.x, p.y + Math.tan((params[0] * Math.PI) / 180) * p.x)\n          )\n          break\n        }\n      }\n    }\n  })\n\n  return ret\n}\n\n// All commands (BbRr isn't supported)\nconst allCommand = /M|m|L|l|H|h|V|v|C|c|S|s|Q|q|T|t|A|a|Z|z/g\n\n/**\n * pathタグd属性文字列を分割する\n * @param dString pathのd要素文字列\n * @return コマンド単位の情報配列の配列\n */\nexport function splitD(dString: string): string[][] {\n  // 要素分割\n  const strList = dString\n    .replace(allCommand, ' $& ')\n    // Insert space before each signature, but don't destruct exponent exporession such as 2.2e-10.\n    .replace(/([^e])(-|\\+)/g, '$1 $2')\n    .split(/,| /)\n    .filter((str) => str)\n    .flatMap(complementDecimalShorthand)\n  // 直前のコマンド\n  let pastCommand = 'M'\n\n  const ret: string[][] = []\n  for (let i = 0; i < strList.length; ) {\n    const info: string[] = []\n    // Check if a command exists\n    if (strList[i].match(allCommand)) {\n      info.push(strList[i])\n      pastCommand = info[0]\n      i++\n    } else if (pastCommand.toUpperCase() !== 'Z') {\n      // Reuse previous command\n      // Avoid reusing 'Z' that can cause infinite loop\n      info.push(pastCommand)\n    }\n\n    switch (info[0].toUpperCase()) {\n      case 'Z':\n        break\n      case 'V':\n      case 'H':\n        info.push(strList[i])\n        i += 1\n        break\n      case 'M':\n      case 'L':\n      case 'T':\n        info.push(strList[i], strList[i + 1])\n        i += 2\n        break\n      case 'Q':\n      case 'S':\n        info.push(strList[i], strList[i + 1], strList[i + 2], strList[i + 3])\n        i += 4\n        break\n      case 'C':\n        info.push(\n          strList[i],\n          strList[i + 1],\n          strList[i + 2],\n          strList[i + 3],\n          strList[i + 4],\n          strList[i + 5]\n        )\n        i += 6\n        break\n      case 'A':\n        info.push(\n          strList[i],\n          strList[i + 1],\n          strList[i + 2],\n          strList[i + 3],\n          strList[i + 4],\n          strList[i + 5],\n          strList[i + 6]\n        )\n        i += 7\n        break\n      default:\n        throw getUnknownError()\n    }\n\n    ret.push(info)\n  }\n\n  return ret\n}\n\n/**\n * '1.2.3' => ['1.2', '0.3']\n */\nfunction complementDecimalShorthand(str: string): string[] {\n  const list = str.split(/\\./)\n  return list.length <= 2\n    ? [str]\n    : [`${list[0]}.${list[1]}`, ...list.slice(2).map((v) => `0.${v}`)]\n}\n\n/**\n * svg文字列を生成する\n * @param pathList path情報リスト\n * @return xml文字列\n */\nexport function serializeSvgString(pathList: ISvgPath[]): string {\n  const svg = serializeSvg(pathList)\n  const xmlSerializer = new XMLSerializer()\n  const textXml = xmlSerializer.serializeToString(svg)\n  return textXml\n}\n\n/**\n * svgタグを生成する\n * @param pathList path情報リスト\n * @return svgタグ\n */\nexport function serializeSvg(pathList: ISvgPath[]): SVGElement {\n  const dom = document.createElementNS(HTTP_SVG, 'svg')\n\n  // キャンバスサイズ\n  let width = 1\n  let height = 1\n\n  pathList.forEach((path) => {\n    dom.appendChild(serializePath(path.d, path.style))\n    path.d.forEach((p) => {\n      width = Math.max(width, p.x)\n      height = Math.max(height, p.y)\n    })\n  })\n\n  width *= 1.1\n  height *= 1.1\n\n  dom.setAttribute('width', `${width}`)\n  dom.setAttribute('height', `${height}`)\n\n  return dom\n}\n\n/**\n * pathタグを生成する\n * @param pointList 座標リスト\n * @param style スタイル情報\n * @return pathタグ\n */\nexport function serializePath(\n  pointList: IVec2[],\n  style: ISvgStyle\n): SVGPathElement {\n  const dom = document.createElementNS(HTTP_SVG, 'path')\n  dom.setAttribute('d', serializePointList(pointList))\n  dom.setAttribute('style', serializeStyle(style))\n  return dom\n}\n\n/**\n * 座標リストをd属性文字列に変換する\n * @param pointList 座標リスト\n * @param open 閉じないフラグ\n * @return d属性文字列\n */\nexport function serializePointList(pointList: IVec2[], open?: boolean): string {\n  if (pointList.length === 0) return ''\n  const [head, ...body] = pointList\n  return (\n    `M ${head.x},${head.y}` +\n    body.map((p) => ` L ${p.x},${p.y}`).join('') +\n    (open ? '' : ' Z')\n  )\n}\n\n/**\n * デフォルトstyle作成\n * @return スタイルオブジェクト\n */\nexport function createStyle(): ISvgStyle {\n  return {\n    fill: false,\n    fillGlobalAlpha: 1,\n    fillStyle: '',\n    lineCap: 'butt',\n    lineDash: [],\n    lineJoin: 'bevel',\n    lineWidth: 1,\n    stroke: false,\n    strokeGlobalAlpha: 1,\n    strokeStyle: '',\n  }\n}\n\n/**\n * pathタグのスタイルを取得する\n * @param svgPath SVGのpathタグDOM\n * @return スタイルオブジェクト\n */\nexport function parseTagStyle(svgPath: SVGElement): ISvgStyle {\n  // スタイル候補要素リスト\n  const styleObject: { [key: string]: string } = {}\n\n  svgPath.getAttributeNames().forEach((name) => {\n    const attr = svgPath.getAttributeNode(name)\n    if (!attr) return\n    styleObject[attr.name] = attr.value\n  })\n\n  const styleAttr = svgPath.getAttributeNode('style')\n  if (styleAttr) {\n    // style要素から取得\n    const styleStr = styleAttr.value\n    styleStr.split(';').forEach((elem: string) => {\n      const splited = elem.split(':')\n      if (splited.length !== 2) return\n      styleObject[splited[0].trim()] = splited[1].trim()\n    })\n  }\n\n  return Object.entries(styleObject).reduce<ISvgStyle>((ret, [key, val]) => {\n    switch (key.toLowerCase()) {\n      case 'fill':\n        if (val === 'none') {\n          ret.fillStyle = ''\n          ret.fill = false\n        } else {\n          ret.fillStyle = val\n          ret.fill = true\n        }\n        break\n      case 'stroke':\n        if (val === 'none') {\n          ret.strokeStyle = ''\n          ret.stroke = false\n        } else {\n          ret.strokeStyle = val\n          ret.stroke = true\n        }\n        break\n      case 'stroke-width':\n        ret.lineWidth = _parseFloat(val)\n        break\n      case 'stroke-opacity':\n        ret.strokeGlobalAlpha = _parseFloat(val)\n        break\n      case 'fill-opacity':\n        ret.fillGlobalAlpha = _parseFloat(val)\n        break\n      case 'stroke-linecap':\n        ret.lineCap = val\n        break\n      case 'stroke-linejoin':\n        ret.lineJoin = val\n        break\n      case 'stroke-dasharray':\n        if (val.toLowerCase() === 'none') {\n          ret.lineDash = []\n        } else {\n          ret.lineDash = parseNumbers(val)\n        }\n        break\n      default:\n        // 無視\n        break\n    }\n\n    return ret\n  }, createStyle())\n}\n\n/**\n * スタイル情報をstyle属性文字列に変換する\n * @method serializeStyle\n * @param style スタイル情報\n * @return style属性文字列\n */\nexport function serializeStyle(style: ISvgStyle): string {\n  let ret = ''\n\n  // fill情報\n  if (!style.fill) {\n    ret += 'fill:none;'\n  } else {\n    ret += 'fill:' + style.fillStyle + ';'\n  }\n  if (style.fillGlobalAlpha) {\n    ret += 'fill-opacity:' + style.fillGlobalAlpha + ';'\n  }\n\n  // stroke情報\n  if (!style.stroke) {\n    ret += 'stroke:none;'\n  } else {\n    ret += 'stroke:' + style.strokeStyle + ';'\n  }\n  if (style.lineWidth) {\n    ret += 'stroke-width:' + style.lineWidth + ';'\n  }\n  if (style.strokeGlobalAlpha) {\n    ret += 'stroke-opacity:' + style.strokeGlobalAlpha + ';'\n  }\n  if (style.lineCap) {\n    ret += 'stroke-linecap:' + style.lineCap + ';'\n  }\n  if (style.lineJoin) {\n    ret += 'stroke-linejoin:' + style.lineJoin + ';'\n  }\n  if (style.lineDash) {\n    if (style.lineDash.length > 0) {\n      ret += 'stroke-dasharray:' + style.lineDash.join(',') + ';'\n    } else {\n      ret += 'stroke-dasharray:none;'\n    }\n  }\n\n  return ret\n}\n\n/**\n * パス分割\n * @param path 対象パス\n * @param line 分割線\n * @return 分割後のパスリスト\n */\nexport function splitPath(path: ISvgPath, line: IVec2[]): ISvgPath[] {\n  let splited = geo.splitPolyByLine(path.d, line)\n  if (splited.length < 2) return [path]\n\n  // 本体と回転方向が一致しているかで分類\n  const rootLoopwise = geo.getLoopwise(path.d)\n  const sameLoopwiseList: IVec2[][] = []\n  const oppositeLoopwiseList: IVec2[][] = []\n  if (path.included) {\n    path.included.forEach((s) => {\n      if (geo.getLoopwise(s) === rootLoopwise) {\n        sameLoopwiseList.push(s)\n      } else {\n        oppositeLoopwiseList.push(s)\n      }\n    })\n  }\n\n  // 本体と同回転のものはそのまま分割\n  sameLoopwiseList.forEach((poly) => {\n    const sp = geo.splitPolyByLine(poly, line)\n    splited = [...splited, ...(sp.length > 0 ? sp : [poly])]\n  })\n\n  // 本体と逆回転のものは特殊処理\n  const notPolyList: IVec2[][] = []\n  oppositeLoopwiseList.forEach((poly) => {\n    const sp = geo.splitPolyByLine(poly, line)\n    if (sp.length > 0) {\n      // 分割されたらブーリアン差をとるために集める\n      notPolyList.push(poly)\n    } else {\n      // 分割なしならそのまま\n      splited.push(poly)\n    }\n  })\n\n  // 切断されたくり抜き領域を差し引いたポリゴンを生成\n  const splitedAfterNot = splited.map((s) =>\n    notPolyList.reduce((p, c) => geo.getPolygonNotPolygon(p, c), s)\n  )\n\n  return geo.getIncludedPolygonGroups(splitedAfterNot).map((group) => {\n    const [d, ...included] = group\n    return { d: d, included, style: path.style }\n  })\n}\n\n/**\n * ポリゴンリストをグルーピングしたパスリストに変換する\n * @param polygons ポリゴンリスト\n * @param style パススタイル\n * @return パスリスト\n */\nexport function getGroupedPathList(\n  polygons: IVec2[][],\n  style: ISvgStyle = createStyle()\n): ISvgPath[] {\n  return geo.getIncludedPolygonGroups(polygons).map((group) => {\n    const [d, ...included] = group\n    return { d, included, style }\n  })\n}\n\n/**\n * convert affine matrix to transform attribute value\n * @param matrix affine matrix\n * @return transform attribute value\n */\nexport function affineToTransform(matrix: AffineMatrix): string {\n  return `matrix(${matrix.join(',')})`\n}\n\n/**\n * parse transform attribute value as affine matrix\n * @param transform attribute value\n * @return transform value\n */\nexport function parseTransform(transformStr: string): AffineMatrix {\n  const transformStrList = transformStr.split(')').map((s) => `${s})`)\n  const affines = transformStrList.map((str) => parseUnitTransform(str))\n  return geo.multiAffines(affines)\n}\n\nfunction parseUnitTransform(str: string): AffineMatrix {\n  if (/translateX/.test(str)) return parseTranslateX(str)\n  if (/translateY/.test(str)) return parseTranslateY(str)\n  if (/translate/.test(str)) return parseTranslate(str)\n  if (/skewX/.test(str)) return parseSkewX(str)\n  if (/skewY/.test(str)) return parseSkewY(str)\n  if (/scaleX/.test(str)) return parseScaleX(str)\n  if (/scaleY/.test(str)) return parseScaleY(str)\n  if (/scale/.test(str)) return parseScale(str)\n  if (/rotate/.test(str)) return parseRotate(str)\n  if (/matrix/.test(str)) return parseMatrix(str)\n  return [...geo.IDENTITY_AFFINE]\n}\n\nfunction parseNumbers(str: string): number[] {\n  const list = str.trim().replace(/,/g, ' ').split(/ +/)\n  return list.map((s) => _parseFloat(s))\n}\n\n/**\n * parse transform attribute value of translate as affine matrix\n * @param transform attribute value\n * @return transform value\n */\nexport function parseTranslate(str: string): AffineMatrix {\n  const splited = str.match(/translate\\((.+)\\)/)\n  if (!splited || splited.length < 1) return [...geo.IDENTITY_AFFINE]\n\n  const numbers = parseNumbers(splited[1])\n  if (numbers.length < 1) {\n    return [...geo.IDENTITY_AFFINE]\n  } else if (numbers.length === 1) {\n    return [1, 0, 0, 1, numbers[0], 0]\n  } else {\n    return [1, 0, 0, 1, numbers[0], numbers[1]]\n  }\n}\n\n/**\n * parse translateX attribute value of translate as affine matrix\n * @param transform attribute value\n * @return transform value\n */\nexport function parseTranslateX(str: string): AffineMatrix {\n  const splited = str.match(/translateX\\((.+)\\)/)\n  if (!splited || splited.length < 1) return [...geo.IDENTITY_AFFINE]\n\n  const numbers = parseNumbers(splited[1])\n  if (numbers.length < 1) {\n    return [...geo.IDENTITY_AFFINE]\n  } else {\n    return [1, 0, 0, 1, numbers[0], 0]\n  }\n}\n\n/**\n * parse translateY attribute value of translate as affine matrix\n * @param transform attribute value\n * @return transform value\n */\nexport function parseTranslateY(str: string): AffineMatrix {\n  const splited = str.match(/translateY\\((.+)\\)/)\n  if (!splited || splited.length < 1) return [...geo.IDENTITY_AFFINE]\n\n  const numbers = parseNumbers(splited[1])\n  if (numbers.length < 1) {\n    return [...geo.IDENTITY_AFFINE]\n  } else {\n    return [1, 0, 0, 1, 0, numbers[0]]\n  }\n}\n\n/**\n * parse skewX attribute value of translate as affine matrix\n * @param transform attribute value\n * @return transform value\n */\nexport function parseSkewX(str: string): AffineMatrix {\n  const splited = str.match(/skewX\\((.+)\\)/)\n  if (!splited || splited.length < 1) return [...geo.IDENTITY_AFFINE]\n\n  const numbers = parseNumbers(splited[1])\n  if (numbers.length < 1) {\n    return [...geo.IDENTITY_AFFINE]\n  } else {\n    return [1, 0, Math.tan((numbers[0] * Math.PI) / 180), 1, 0, 0]\n  }\n}\n\n/**\n * parse skewY attribute value of translate as affine matrix\n * @param transform attribute value\n * @return transform value\n */\nexport function parseSkewY(str: string): AffineMatrix {\n  const splited = str.match(/skewY\\((.+)\\)/)\n  if (!splited || splited.length < 1) return [...geo.IDENTITY_AFFINE]\n\n  const numbers = parseNumbers(splited[1])\n  if (numbers.length < 1) {\n    return [...geo.IDENTITY_AFFINE]\n  } else {\n    return [1, Math.tan((numbers[0] * Math.PI) / 180), 0, 1, 0, 0]\n  }\n}\n\n/**\n * parse transform attribute value of scale as affine matrix\n * @param transform attribute value\n * @return transform value\n */\nexport function parseScale(str: string): AffineMatrix {\n  const splited = str.match(/scale\\((.+)\\)/)\n  if (!splited || splited.length < 2) return [...geo.IDENTITY_AFFINE]\n\n  const numbers = parseNumbers(splited[1])\n  if (numbers.length < 1) {\n    return [...geo.IDENTITY_AFFINE]\n  } else if (numbers.length === 1) {\n    return [numbers[0], 0, 0, numbers[0], 0, 0]\n  } else {\n    return [numbers[0], 0, 0, numbers[1], 0, 0]\n  }\n}\n\n/**\n * parse ScaleX attribute value of translate as affine matrix\n * @param transform attribute value\n * @return transform value\n */\nexport function parseScaleX(str: string): AffineMatrix {\n  const splited = str.match(/scaleX\\((.+)\\)/)\n  if (!splited || splited.length < 1) return [...geo.IDENTITY_AFFINE]\n\n  const numbers = parseNumbers(splited[1])\n  if (numbers.length < 1) {\n    return [...geo.IDENTITY_AFFINE]\n  } else {\n    return [numbers[0], 0, 0, 1, 0, 0]\n  }\n}\n\n/**\n * parse ScaleY attribute value of translate as affine matrix\n * @param transform attribute value\n * @return transform value\n */\nexport function parseScaleY(str: string): AffineMatrix {\n  const splited = str.match(/scaleY\\((.+)\\)/)\n  if (!splited || splited.length < 1) return [...geo.IDENTITY_AFFINE]\n\n  const numbers = parseNumbers(splited[1])\n  if (numbers.length < 1) {\n    return [...geo.IDENTITY_AFFINE]\n  } else {\n    return [1, 0, 0, numbers[0], 0, 0]\n  }\n}\n\n/**\n * parse transform attribute value of rotate as affine matrix\n * @param transform attribute value\n * @return transform value\n */\nexport function parseRotate(str: string): AffineMatrix {\n  const splited = str.match(/rotate\\((.+)\\)/)\n  if (!splited || splited.length < 2) return [...geo.IDENTITY_AFFINE]\n\n  const numbers = parseNumbers(splited[1])\n  if (parseNumbers.length < 1) return [...geo.IDENTITY_AFFINE]\n\n  const rad = (numbers[0] / 180) * Math.PI\n  const cos = Math.cos(rad)\n  const sin = Math.sin(rad)\n  const rot: AffineMatrix = [cos, sin, -sin, cos, 0, 0]\n\n  if (numbers.length > 2) {\n    return geo.multiAffine(\n      geo.multiAffine([1, 0, 0, 1, numbers[1], numbers[2]], rot),\n      [1, 0, 0, 1, -numbers[1], -numbers[2]]\n    )\n  } else {\n    return rot\n  }\n}\n\n/**\n * parse transform attribute value of matrix as affine matrix\n * @param transform attribute value\n * @return transform value\n */\nexport function parseMatrix(str: string): AffineMatrix {\n  const splited = str.match(/matrix\\((.+)\\)/)\n  if (!splited || splited.length < 2) return [...geo.IDENTITY_AFFINE]\n\n  const numbers = parseNumbers(splited[1])\n  if (numbers.length < 5) return [...geo.IDENTITY_AFFINE]\n\n  return numbers.slice(0, 6) as AffineMatrix\n}\n\nfunction getUnknownError(): Error {\n  return new Error(`Unexpected error`)\n}\n"],"names":[],"version":3,"file":"index.70ebd9cc.js.map"}