{"version":3,"sources":["geo.ts","svg.ts","okageo.ts"],"names":[],"mappings":"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","file":"okageo.map","sourceRoot":"../src","sourcesContent":["import { IVec2 } from '../types/index'\n\nexport const MINVALUE: number = 0.000001\n\nexport function add (a: IVec2, b: IVec2): IVec2 {\n  return { x: a.x + b.x, y: a.y + b.y }\n}\n\nexport function sub (a: IVec2, b: IVec2): IVec2 {\n  return { x: a.x - b.x, y: a.y - b.y }\n}\n\nexport function multi (a: IVec2, b: number): IVec2 {\n  return { x: a.x * b, y: a.y * b }\n}\n\nexport function isSame (a: IVec2, b: IVec2): boolean {\n  const dif: IVec2 = sub(a, b)\n  return (Math.abs(dif.x) < MINVALUE) && (Math.abs(dif.y) < MINVALUE)\n}\n\nexport function getDistance (a: IVec2, b: IVec2): number {\n  const dif: IVec2 = sub(a, b)\n  return Math.sqrt(dif.x * dif.x + dif.y * dif.y)\n}\n\nexport function getNorm (a: IVec2): number {\n  return getDistance(a, { x: 0, y: 0 })\n}\n\nexport function isZero (a: IVec2): boolean {\n  return getNorm(a) < MINVALUE\n}\n\nexport function getUnit (a: IVec2): IVec2 {\n  const d = getNorm(a)\n  if (d < MINVALUE) throw new Error('cannot get unit vector of zero vector')\n  return multi(a, 1 / d)\n}\n\nexport function getCross (a: IVec2, b: IVec2): number {\n  return a.x * b.y - a.y * b.x\n}\n\nexport function getInner (a: IVec2, b: IVec2): number {\n  return a.x * b.x + a.y * b.y\n}\n\nexport function cloneVectors (vectors: IVec2[]): IVec2[] {\n  return vectors.map((v) => ({ ...v }))\n}\n\nexport function getCenter (a: IVec2, b: IVec2): IVec2 {\n  return multi(add(a, b), 1 / 2)\n}\n\nexport function getRadian (a: IVec2, from: IVec2 = { x: 0, y: 0 }): number {\n  const dif = sub(a, from)\n  return Math.atan2(dif.y, dif.x)\n}\n\n/**\n * fromに対して、aと点対称なベクトル取得\n * @param a 対象ベクトル\n * @param from 基点\n * @param 点対称ベクトル\n */\nexport function getSymmetry (a: IVec2, from: IVec2 = { x: 0, y: 0 }): IVec2 {\n  return add(multi(sub(from, a), 2), a)\n}\n\n/**\n * fromに対して、aからradian回転したベクトル取得\n * @param a 対象ベクトル\n * @param radian 回転ラジアン\n * @param from 基点\n * @param 回転後のベクトル\n */\nexport function rotate (a: IVec2, radian: number, from: IVec2 = { x: 0, y: 0 }): IVec2 {\n  const fromBase: IVec2 = sub(a, from)\n  return add({\n    x: Math.cos(radian) * fromBase.x - Math.sin(radian) * fromBase.y,\n    y: Math.sin(radian) * fromBase.x + Math.cos(radian) * fromBase.y\n  }, from)\n}\n\n/**\n * 2次方程式の解の公式\n * a * x^2 + b * x + c = 0\n * 解に虚数が含まれる場合は解なし扱い\n * @param a x^2の係数\n * @param b xの係数\n * @param c 定数\n * @return 解の配列\n */\nexport function solveEquationOrder2 (a: number, b: number, c: number): number[] {\n  if (a === 0) {\n    return b === 0 ? [] : [-c / b]\n  }\n\n  const d = b * b - 4 * a * c\n  if (d < 0) {\n    return []\n  }\n\n  const ia = 0.5 / a\n\n  if (d === 0) {\n    return [-b * ia]\n  }\n\n  const sd = Math.sqrt(d)\n  return [(-b + sd) * ia, (-b - sd) * ia]\n}\n\n/**\n * 点から直線への垂線の足\n * @param p 対象の点\n * @param line 直線\n * @return 垂線の足\n */\nexport function getPedal (p: IVec2, line: IVec2[]): IVec2 {\n  if (line.length !== 2) throw new Error('line must be length = 2')\n  const s = line[0]\n  const t = line[1]\n  const vecST = sub(t, s)\n  const vecSP = sub(p, s)\n  const inner = getInner(vecST, vecSP)\n  const rate = inner / getInner(vecST, vecST)\n  return add(s, multi(vecST, rate))\n}\n\n/**\n * 2次ベジェ曲線と直線の当たり判定用パラメータを取得する\n * @param p0 ベジェ曲線始点\n * @param p1 ベジェ曲線制御点\n * @param p2 ベジェ曲線終点\n * @param p 直線始点\n * @param q 直線終点\n * @return ベジェ曲線パラメータ配列\n */\nfunction rayToBezier (p0: IVec2, p1: IVec2, p2: IVec2, p: IVec2, q: IVec2): number[] {\n  const vx: number = q.x - p.x\n  const vy: number = q.y - p.y\n  const a: number = p0.x - 2 * p1.x + p2.x\n  const b: number = 2 * (p1.x - p0.x)\n  const c: number = p0.x\n  const d: number = p0.y - 2 * p1.y + p2.y\n  const e: number = 2 * (p1.y - p0.y)\n  const f: number = p0.y\n\n  return solveEquationOrder2(\n    a * vy - vx * d,\n    b * vy - vx * e,\n    vy * c - vy * p.x - vx * f + vx * p.y\n  )\n}\n\n/**\n * 2次ベジェ曲「線分」と「直線」の交点を取得する\n * @method crossLineAndBezier\n * @param p0 ベジェ曲線始点\n * @param p1 ベジェ曲線制御点\n * @param p2 ベジェ曲線終点\n * @param p 直線始点\n * @param q 直線終点\n * @return 交点リスト\n */\nexport function getCrossLineAndBezier (p0: IVec2, p1: IVec2, p2: IVec2, p: IVec2, q: IVec2) {\n  return rayToBezier(p0, p1, p2, p, q)\n    .filter((t) => 0 <= t && t <= 1)\n    .map((t) => ({\n      x: (p2.x - 2 * p1.x + p0.x) * t * t + 2 * (p1.x - p0.x) * t + p0.x,\n      y: (p2.y - 2 * p1.y + p0.y) * t * t + 2 * (p1.y - p0.y) * t + p0.y\n    }))\n}\n\n/**\n * 線分と線分の交差判定（端点での接触は含まない）\n * @param seg1 線分1\n * @param seg2 線分2\n * @return 交差しているフラグ\n */\nexport function isCrossSegAndSeg (seg1: IVec2[], seg2: IVec2[]): boolean {\n  const { ta, tb, tc, td } = getCrossSegAndSegParams(seg1, seg2)\n  return tc * td < 0 && ta * tb < 0\n}\n\n/**\n * 線分と線分の接触判定（端点での接触含む）\n * @param seg1 線分1\n * @param seg2 線分2\n * @return 接触しているフラグ\n */\nexport function isTouchSegAndSeg (seg1: IVec2[], seg2: IVec2[]): boolean {\n  const { ta, tb, tc, td } = getCrossSegAndSegParams(seg1, seg2)\n  return tc * td <= 0 && ta * tb <= 0\n}\n\nfunction getCrossSegAndSegParams (seg1: IVec2[], seg2: IVec2[]): {\n  ta: number,\n  tb: number,\n  tc: number,\n  td: number\n} {\n  const ax = seg1[0].x\n  const ay = seg1[0].y\n  const bx = seg1[1].x\n  const by = seg1[1].y\n  const cx = seg2[0].x\n  const cy = seg2[0].y\n  const dx = seg2[1].x\n  const dy = seg2[1].y\n  const ta = (cx - dx) * (ay - cy) + (cy - dy) * (cx - ax)\n  const tb = (cx - dx) * (by - cy) + (cy - dy) * (cx - bx)\n  const tc = (ax - bx) * (cy - ay) + (ay - by) * (ax - cx)\n  const td = (ax - bx) * (dy - ay) + (ay - by) * (ax - dx)\n  return { ta, tb, tc, td }\n}\n\n/**\n * 平行判定\n * @param a ベクトル or 2点の配列\n * @param b 同上\n * @return 平行であるフラグ\n */\nexport function isParallel (a: IVec2, b: IVec2): boolean {\n  const cross = getCross(a, b)\n  return Math.abs(cross) < MINVALUE\n}\n\n/**\n * 点が直線上にあるか判定\n * @param p 点\n * @param line 直線\n * @return 直線上にあるフラグ\n */\nexport function isOnLine (p: IVec2, line: IVec2[]): boolean {\n  return isZero(sub(p, getPedal(p, line)))\n}\n\n/**\n * 点が面上にあるか判定（境界線上を含む）\n * @param p 点\n * @param polygon 面\n * @return 面上にあるフラグ\n */\nexport function isOnPolygon (p: IVec2, polygon: IVec2[]): boolean {\n  // 頂点上判定\n  if (polygon.find((point) => p.x === point.x && p.y === point.y)) return true\n\n  const segs: IVec2[][] = polygon.map((point, i) => {\n    return [point, i < polygon.length - 1 ? polygon[i + 1] : polygon[0]]\n  })\n\n  // pからx方向への直線と面の各辺との交差回数から判定する\n  const hitSegs = segs.filter((seg) => {\n    const maxX: number = Math.max(seg[0].x, seg[1].x)\n    if (maxX < p.x) return false\n    if (seg[0].y < p.y && seg[1].y < p.y) return false\n    if (p.y < seg[0].y && p.y < seg[1].y) return false\n    if (seg[0].y === seg[1].y) {\n      // 水平な辺上の場合、他の辺の端点もカウントされて偶奇がずれるので無視\n      return false\n    }\n    return isTouchSegAndSeg(\n      seg,\n      [p, { x: maxX + 1, y: p.y }]\n    )\n  })\n  return hitSegs.length % 2 === 1\n}\n\n/**\n * 線分と直線の交点取得\n * @param seg 線分\n * @param line 直線\n * @return 交点\n */\nexport function getCrossSegAndLine (seg: IVec2[], line: IVec2[]): IVec2 | null {\n  if (isParallel(sub(seg[0], seg[1]), sub(line[0], line[1]))) return null\n  if (isOnLine(seg[0], line)) return { ...seg[0] }\n  if (isOnLine(seg[1], line)) return { ...seg[1] }\n\n  const s1 = ((line[1].x - line[0].x) * (seg[0].y - line[0].y) - (line[1].y - line[0].y) * (seg[0].x - line[0].x)) / 2\n  const s2 = ((line[1].x - line[0].x) * (line[0].y - seg[1].y) - (line[1].y - line[0].y) * (line[0].x - seg[1].x)) / 2\n  const rate = s1 / (s1 + s2)\n  const isExistCorss = 0 < rate && rate < 1\n\n  return isExistCorss ? {\n    x: seg[0].x + (seg[1].x - seg[0].x) * rate,\n    y: seg[0].y + (seg[1].y - seg[0].y) * rate\n  } : null\n}\n\n/**\n * 同一線分かを判定する\n * @param ab 線分ab\n * @param cd 線分cd\n * @return 同一であるフラグ\n */\nexport function isSameSeg (ab: IVec2[], cd: IVec2[]): boolean {\n  if (isSame(ab[0], cd[0]) && isSame(ab[1], cd[1])) return true\n  if (isSame(ab[0], cd[1]) && isSame(ab[1], cd[0])) return true\n  return false\n}\n\n/**\n * ポリゴンを直線で分割する\n * @param pol 面\n * @param line 直線\n * @return 分割された点配列の配列\n */\nexport function splitPolyByLine (pol: IVec2[], line: IVec2[]): IVec2[][] {\n  let points: IVec2[] = []\n  let crossIndex: number[] = []\n  let crossList: IVec2[] = []\n\n  pol.forEach((p, i) => {\n    const targetLine = [p, pol[(i + 1) % pol.length]]\n    const cross = getCrossSegAndLine(targetLine, line)\n    points.push(p)\n    if (cross) {\n      points.push(cross)\n      crossIndex.push(i + 1 + crossIndex.length)\n      crossList.push(cross)\n    }\n  })\n\n  if (crossIndex.length % 2 !== 0) return []\n\n  // 近い順に並べる -> 直線をx軸と重なるよう回転してx座標で比較\n  const rad: number = getRadian(line[0], line[1])\n  crossList.sort((a, b) => rotate(a, -rad).x - rotate(b, -rad).x)\n\n  // 面の辺と同一ではないものを採用\n  let targetSection: IVec2[] = []\n  for (let k = 0; k < crossList.length - 1; k += 2) {\n    const section = [crossList[k], crossList[k + 1]]\n    let sameSeg = false\n    for (let l = 0; l < pol.length; l++) {\n      if (isSameSeg(section, [pol[l], pol[(l + 1) % pol.length]])) {\n        sameSeg = true\n        break\n      }\n    }\n\n    if (!sameSeg) {\n      targetSection = section\n      break\n    }\n  }\n\n  if (targetSection.length !== 2) return []\n\n  // 除外対象回収\n  const dropList = crossList.concat()\n  let tmpIndex = dropList.indexOf(targetSection[0])\n  if (tmpIndex !== -1) {\n    dropList.splice(tmpIndex, 1)\n  }\n  tmpIndex = dropList.indexOf(targetSection[1])\n  if (tmpIndex !== -1) {\n    dropList.splice(tmpIndex, 1)\n  }\n  const tmpList = points.concat()\n  dropList.forEach((p) => {\n    const i = tmpList.indexOf(p)\n    tmpList.splice(i, 1)\n  })\n\n  points = tmpList\n  crossList = targetSection\n\n  const i0 = points.indexOf(crossList[0])\n  const i1 = points.indexOf(crossList[1])\n\n  if (i0 === -1 || i1 === -1) return []\n\n  crossIndex = []\n  crossIndex[0] = Math.min(i0, i1)\n  crossIndex[1] = Math.max(i0, i1)\n\n  // 分割ポリゴンを拾い集める\n  const splitedPolygons = []\n\n  // 1つ目\n  let splitPol = []\n  // 交点まで追加\n  for (let i = 0; i <= crossIndex[0]; i++) {\n    splitPol.push({\n      x: points[i].x,\n      y: points[i].y\n    })\n  }\n  // 交点から追加\n  for (let i = crossIndex[1]; i < points.length; i++) {\n    splitPol.push({\n      x: points[i].x,\n      y: points[i].y\n    })\n  }\n  // 確定\n  splitedPolygons.push(splitPol)\n\n  // 2つ目\n  splitPol = []\n  // 交点から交点まで追加\n  for (let i = crossIndex[0]; i <= crossIndex[1]; i++) {\n    splitPol.push({\n      x: points[i].x,\n      y: points[i].y\n    })\n  }\n  // 確定\n  splitedPolygons.push(splitPol)\n\n  // 再帰的に分割\n  const recursiveResult: IVec2[][] = []\n  splitedPolygons.forEach((polygon) => {\n    const splited = splitPolyByLine(polygon, line)\n    if (splited.length === 0) {\n      recursiveResult.push(polygon)\n    } else {\n      recursiveResult.push(...splited)\n    }\n  })\n\n  return recursiveResult\n}\n\n/**\n * 三角分割\n * @param polygon 面\n * @return 分割面リスト\n */\nexport function triangleSplit (polygon: IVec2[]): IVec2[][] {\n  // 時計周りに揃える\n  polygon = convertLoopwise(polygon)\n\n  // ポリゴン複製\n  const targetPoly = omitSamePoint(polygon)\n\n  // 最遠点のインデックス\n  let farthestIndex = 0\n  // 現在の最遠点と前後点で作った三角形の外積\n  let currentCross = 0\n  // 分割後の面リスト\n  const triangleList = []\n\n      // ループ\n  while (targetPoly.length >= 3) {\n    // 最遠点インデックス取得\n    const sorted = targetPoly.concat()\n    sorted.sort((a, b) => {\n      return getNorm(b) - getNorm(a)\n    })\n    farthestIndex = targetPoly.indexOf(sorted[0])\n\n    // 分割実行\n    let tri = getTriangle(targetPoly, farthestIndex)\n    if (!tri) {\n      // 最遠点では失敗\n      const size = targetPoly.length\n      // 外積計算\n      const pa = sub(targetPoly[(farthestIndex + 1) % size], targetPoly[farthestIndex])\n      const pb = sub(targetPoly[(farthestIndex - 1 < 0) ? size - 1 : farthestIndex - 1], targetPoly[farthestIndex])\n\n      currentCross = getCross(pa, pb)\n\n      let index = farthestIndex\n      // 最遠点以外で探す\n      while (!tri) {\n        index = (index + 1) % size\n        // 最遠点の外積と同じ符号かを判定\n        const v1 = sub(targetPoly[(index + 1) % size], targetPoly[index])\n        const v2 = sub(targetPoly[(index - 1 < 0) ? size - 1 : index - 1], targetPoly[index])\n        const tmpCross = getCross(v1, v2)\n        if (tmpCross * currentCross > 0) {\n              // 判定続行\n          tri = getTriangle(targetPoly, index)\n        }\n        if (index === farthestIndex) {\n          throw new Error('failed to split triangles')\n        }\n      }\n\n      // 採用された点を削除\n      targetPoly.splice(index, 1)\n    } else {\n      // 最遠点削除\n      targetPoly.splice(farthestIndex, 1)\n    }\n    triangleList.push(tri)\n  }\n  return triangleList\n}\n\n/**\n * 面から三角形を取得する\n * @param polygon 面\n * @param index このインデックスの点とその両側の点で三角形を作る\n * @return 三角形、内部に入り込む点がある場合はnull\n */\nfunction getTriangle (polygon: IVec2[], index: number): IVec2[] | null {\n  // indexとその前後点で三角形作成\n  const size = polygon.length\n  const p0 = polygon[index]\n  const p1 = polygon[(index + 1) % size]\n  const p2 = polygon[(index - 1 < 0) ? size - 1 : index - 1]\n\n  const tri: IVec2[] = [p0, p1, p2]\n\n  // 内部に点が入り込まないか判定\n  let invalid: boolean = false\n  polygon.some((p) => {\n    if (p !== p0 && p !== p1 && p !== p2) {\n      if (isPointOnTriangle(tri, p)) {\n            // 失敗\n        invalid = true\n      }\n    }\n    return invalid\n  })\n\n  return invalid ? null : tri\n}\n\n/**\n * 点が三角形内にあるかを判定する\n * 境界も含む\n * @param tri 三角形\n * @param p 点\n * @return 内部にあるフラグ\n */\nexport function isPointOnTriangle (tri: IVec2[], p: IVec2): boolean {\n  // 三角形の3つのベクトル\n  const ab = sub(tri[1], tri[0])\n  const bc = sub(tri[2], tri[1])\n  const ca = sub(tri[0], tri[2])\n\n  // 三角形の各点からpへのベクトル\n  const ap = sub(p, tri[0])\n  const bp = sub(p, tri[1])\n  const cp = sub(p, tri[2])\n\n  // 外積を求める\n  const crossABP = getCross(ab, bp)\n  const crossBCP = getCross(bc, cp)\n  const crossCAP = getCross(ca, ap)\n\n  // 外積の符号が全て同じなら内部にある\n  // 0も含む→境界も含む\n  if ((crossABP >= 0 && crossBCP >= 0 && crossCAP >= 0) ||\n        (crossABP <= 0 && crossBCP <= 0 && crossCAP <= 0)) {\n    return true\n  }\n\n  return false\n}\n\n/**\n * 面を時計回りに変換する\n * @param {vector[]} 面\n * @return 時計回りにした面(引数とは別配列にする)\n */\nexport function convertLoopwise (polygon: IVec2[]): IVec2[] {\n  const ret = polygon.concat()\n  if (getLoopwise(polygon) === -1) {\n    ret.reverse()\n  }\n  return ret\n}\n\n/**\n * 面の座標が時計回りかを判定する\n * @param polygon 面\n * @return -1:反時計 0:不定 1:時計\n */\nexport function getLoopwise (polygon: IVec2[]): number {\n  const area = getArea(polygon, true)\n  if (area > 0) return 1\n  if (area < 0) return -1\n  return 0\n}\n\n/**\n * 面積取得\n * @param polygon 面\n * @param allowNegative 負値を許すフラグ\n * @return 面積\n */\nexport function getArea (polygon: IVec2[], allowNegative: boolean = false): number {\n  if (polygon.length < 3) return 0\n\n  let area = 0\n  const size = polygon.length\n  for (let i = 0; i < size - 1; i++) {\n    area += (polygon[i].x - polygon[i + 1].x) * (polygon[i].y + polygon[i + 1].y)\n  }\n  // 最後分\n  area += (polygon[size - 1].x - polygon[0].x) * (polygon[size - 1].y + polygon[0].y)\n\n  area /= 2\n\n  // 負値を許さないなら絶対値\n  if (!allowNegative) {\n    area = Math.abs(area)\n  }\n\n  return area\n}\n\n/**\n * ベジェ曲線を直線で近似する(３次まで対応)\n * @param pointList 制御点リスト\n * @param size 分割数(1なら制御点両端のみ)\n * @return 座標リスト\n */\nexport function approximateBezier (pointList: IVec2[], size: number): IVec2[] {\n  const ret: IVec2[] = []\n  const unitT: number = 1 / size\n\n  if (pointList.length === 3) {\n    // ２次ベジェの場合\n    for (let i = 0; i <= size; i++) {\n      const t = unitT * i\n      const c0 = multi(pointList[0], (1 - t) * (1 - t))\n      const c1 = multi(pointList[1], 2 * t * (1 - t))\n      const c2 = multi(pointList[2], t * t)\n      ret.push({\n        x : c0.x + c1.x + c2.x,\n        y : c0.y + c1.y + c2.y\n      })\n    }\n  } else if (pointList.length === 4) {\n    // 3次ベジェの場合\n    for (let i = 0; i <= size; i++) {\n      const t = unitT * i\n      const c0 = multi(pointList[0], (1 - t) * (1 - t) * (1 - t))\n      const c1 = multi(pointList[1], 3 * t * (1 - t) * (1 - t))\n      const c2 = multi(pointList[2], 3 * t * t * (1 - t))\n      const c3 = multi(pointList[3], t * t * t)\n      ret.push({\n        x : c0.x + c1.x + c2.x + c3.x,\n        y : c0.y + c1.y + c2.y + c3.y\n      })\n    }\n  } else {\n    throw new Error('connot approximate')\n  }\n\n  return ret\n}\n\n/**\n * 円弧を直線で近似する\n * @param rx x軸半径\n * @param ry y軸半径\n * @param startRadian 開始ラジアン\n * @param endRadian 終了ラジアン\n * @param center 中心座標\n * @param radian 傾き\n * @param size 分割数\n * @return 座標リスト\n */\nexport function approximateArc (\n  rx: number,\n  ry: number,\n  startRadian: number,\n  endRadian: number,\n  center: IVec2,\n  radian: number,\n  size: number\n): IVec2[] {\n  const ret = []\n  const range = endRadian - startRadian\n  const unitT = range / size\n\n  for (let i = 0; i <= size; i++) {\n    const t = unitT * i + startRadian - radian\n    ret.push(add(rotate({\n      x : rx * Math.cos(t),\n      y : ry * Math.sin(t)\n    }, radian), center))\n  }\n\n  return ret\n}\n\n/**\n * ２点指定の円弧を直線で近似する\n * https://triple-underscore.github.io/SVG11/paths.html#PathDataEllipticalArcCommands\n * @method approximateArcWithPoint\n * @param rx x軸半径\n * @param ry y軸半径\n * @param startPoint 開始点\n * @param endPoint 終了点\n * @param largeArcFlag 円弧の大きい側を使うフラグ\n * @param sweepFlag 時計回り円弧を使うフラグ\n * @param radian 傾き\n * @param size 分割数\n * @return 座標リスト\n */\nexport function approximateArcWithPoint (\n  rx: number,\n  ry: number,\n  startPoint: IVec2,\n  endPoint: IVec2,\n  largeArcFlag: boolean,\n  sweepFlag: boolean,\n  radian: number,\n  size: number\n): IVec2[] {\n  // 範囲外の径の修正\n  // https://triple-underscore.github.io/SVG11/implnote.html#ArcImplementationNotes\n  // 径長ゼロを弾く\n  if (rx * ry === 0) return [startPoint, endPoint]\n\n  // 負の径長を訂正する\n  rx = Math.abs(rx)\n  ry = Math.abs(ry)\n\n  // 楕円中心取得\n  const centerInfo = getEllipseCenter(startPoint, endPoint, rx, ry, radian)\n  const centers = centerInfo.centers\n\n  // 径長を十分大きくする\n  rx *= centerInfo.radiusRate\n  ry *= centerInfo.radiusRate\n\n  let center = null\n\n  if ((largeArcFlag && sweepFlag) || (!largeArcFlag && !sweepFlag)) {\n    // 時計回り＆大きい側\n    // 反時計回り＆小さい側\n    // →始点終点中心が反時計回りになる\n    if (getLoopwise([startPoint, endPoint, centers[0]]) < 0) {\n      center = centers[0]\n    } else {\n      center = centers[1]\n    }\n  } else {\n    if (getLoopwise([startPoint, endPoint, centers[0]]) > 0) {\n      center = centers[0]\n    } else {\n      center = centers[1]\n    }\n  }\n\n  // 回り方に応じて始点と終点を設定\n  let startRadian = 0\n  let endRadian = 0\n  const r1 = getRadianOnArc(startPoint, rx, center, radian)\n  const r2 = getRadianOnArc(endPoint, rx, center, radian)\n  if (sweepFlag) {\n    if (r1 > r2) {\n      startRadian = r1 - Math.PI * 2\n      endRadian = r2\n    } else {\n      startRadian = r1\n      endRadian = r2\n    }\n  } else {\n    if (r1 > r2) {\n      startRadian = r1\n      endRadian = r2\n    } else {\n      startRadian = r1\n      endRadian = r2 - Math.PI * 2\n    }\n  }\n\n  return approximateArc(\n    rx,\n    ry,\n    startRadian,\n    endRadian,\n    center,\n    radian,\n    size\n  )\n}\n\n/**\n * 円弧上の点の角度を求める\n * @param a 円弧上の点\n * @param rx x径長\n * @param center 中心座標\n * @param radian 傾き\n * @return ラジアン(0 <= t <= 2 * Math.PI)\n */\nfunction getRadianOnArc (\n  a: IVec2,\n  rx: number,\n  center: IVec2,\n  radian: number\n): number {\n  // 回転打ち消し\n  a = rotate(a, -radian, center)\n  let ret = Math.acos((a.x - center.x) / rx)\n\n  // y座標の位置をみて絞り込み\n  if (a.y - center.y < 0) {\n    ret = -ret + Math.PI * 2\n  }\n\n  // 回転戻す\n  ret += radian\n  ret %= Math.PI * 2\n\n  return ret\n}\n\n/**\n * ２点を通る楕円の中心を求める\n * @param a 点a\n * @param b 点b\n * @param rx x軸半径\n * @param ry y軸半径\n * @param radian 傾き\n * @return 解となる２点\n * @return { centers: 解となる２点, radiusRate: 半径補正係数 }\n */\nexport function getEllipseCenter (\n  a: IVec2,\n  b: IVec2,\n  rx: number,\n  ry: number,\n  radian: number\n): { centers: IVec2[], radiusRate: number } {\n  // 回転を打ち消す\n  a = rotate(a, -radian)\n  b = rotate(b, -radian)\n\n  // 媒介変数を利用して円の中心問題にする\n  const A = {\n    x : a.x / rx,\n    y : a.y / ry\n  }\n  const B = {\n    x : b.x / rx,\n    y : b.y / ry\n  }\n\n  // 円の中心取得\n  const centerInfo = getCircleCenter(A, B, 1)\n  const C = centerInfo.centers\n\n  // 楕円に戻す\n  let ans1 = {\n    x : C[0].x * rx,\n    y : C[0].y * ry\n  }\n  let ans2 = {\n    x : C[1].x * rx,\n    y : C[1].y * ry\n  }\n\n  // 回転を戻す\n  ans1 = rotate(ans1, radian)\n  ans2 = rotate(ans2, radian)\n\n  return {\n    centers: [ans1, ans2],\n    radiusRate: centerInfo.radiusRate\n  }\n}\n\n/**\n * ２点を通る円の中心を求める\n * @param a 点a\n * @param b 点b\n * @param radius 半径\n * @return { centers: 解となる２点, radiusRate: 半径補正係数 }\n */\nexport function getCircleCenter (\n  a: IVec2,\n  b: IVec2,\n  radius: number\n): { centers: IVec2[], radiusRate: number } {\n  const u1 = (a.x + b.x) / 2\n  const u2 = (a.x - b.x) / 2\n  const v1 = (a.y + b.y) / 2\n  const v2 = (a.y - b.y) / 2\n  const L = Math.sqrt(u2 * u2 + v2 * v2)\n  const t2 = Math.pow((radius / L), 2) - 1\n\n  // 2点が直径以上に離れている => 2点を直径とみなす\n  if (t2 < 0) {\n    const center = getCenter(a, b)\n    return {\n      centers: [center, center],\n      radiusRate: L / radius\n    }\n  }\n\n  const t = Math.sqrt(t2)\n  const ans1 = {\n    x : u1 + v2 * t,\n    y : v1 - u2 * t\n  }\n  const ans2 = {\n    x : u1 - v2 * t,\n    y : v1 + u2 * t\n  }\n\n  return {\n    centers: [ans1, ans2],\n    radiusRate: 1\n  }\n}\n\n/**\n * 2次元アフィン変換を行う\n * paramsには以下の行列をa b c d e fの順で指定する\n * a c e\n * b d f\n * @param points 変換前の座標リスト\n * @param params 行列成分\n * @return 座標リスト\n */\nexport function transform (points: IVec2[], params: number[]): IVec2[] {\n  const a = params[0]\n  const b = params[1]\n  const c = params[2]\n  const d = params[3]\n  const e = params[4]\n  const f = params[5]\n\n  return points.map((p) => ({\n    x : a * p.x + c * p.y + e,\n    y : b * p.x + d * p.y + f\n  }))\n}\n\n/**\n * 隣り合う同一点をオミットする\n * @method omitSamePoint\n * @param polygon ポリゴン\n * @return オミット後のポリゴン\n */\nexport function omitSamePoint (polygon: IVec2[]): IVec2[] {\n  let ret = polygon.concat()\n\n  // サイズ\n  const size = polygon.length\n  // 同一点探す\n  for (let i = 0; i < size; i++) {\n    const p1 = ret[i]\n    const p2 = ret[(i + 1) % size]\n    if (isSame(p1, p2)) {\n      // 同一\n      ret.splice(i, 1)\n      // 再帰\n      ret = omitSamePoint(ret)\n      break\n    }\n  }\n\n  return ret\n}\n\n/**\n * 正多角形の面積を内接円の半径から求める\n * @param radius 半径\n * @param n 角数\n * @return 面積\n */\nexport function getRegularPolygonArea (radius: number, n: number): number {\n  const unitRad = Math.PI / n\n  const unitArea = Math.pow(radius, 2) * Math.sin(unitRad) * Math.cos(unitRad)\n  return unitArea * n\n}\n\n/**\n * 正多角形の面積から内接円の半径を求める\n * @param area 面積\n * @param n 角数\n * @return 半径\n */\nexport function getRegularPolygonRadius (area: number, n: number): number {\n  const unitRad = Math.PI / n\n  const unitArea = area / n\n  return Math.sqrt(unitArea / Math.sin(unitRad) / Math.cos(unitRad))\n}\n\n/**\n * 包含関係にあるポリゴンをグループ化する\n * @param polygons ポリゴン一覧\n * @return グループ化したポリゴン一覧、グループ内は面積降順\n */\nexport function getIncludedPolygonGroups (polygons: IVec2[][]): IVec2[][][] {\n  const sorted = polygons.concat()\n  sorted.sort((a, b) => {\n    return getArea(b) - getArea(a)\n  })\n  const hit: { [s: string]: boolean } = {}\n  const ret: IVec2[][][] = []\n  sorted.forEach((p, i) => {\n    if (hit[i]) return\n    hit[i] = true\n    const group = [p].concat(sorted.filter((c, j) => {\n      if (hit[j]) return false\n      const pointsOnPolygon = c.filter((point) => isOnPolygon(point, p))\n      if (pointsOnPolygon.length !== c.length) return false\n      hit[j] = true\n      return true\n    }))\n    ret.push(group)\n  })\n  return ret\n}\n","import { ISvgConfigs, ISvgPath, ISvgStyle, IVec2 } from '../types/index'\nimport * as geo from './geo'\n\nexport const configs: ISvgConfigs = {\n  bezierSplitSize: 10,\n  ellipseSplitSize: 20\n}\n\n/**\n * 描画\n * @param ctx 描画要素\n * @param pathInfo 図形情報\n */\nexport function draw (ctx: CanvasRenderingContext2D, pathInfo: ISvgPath): void {\n  ctx.lineCap = pathInfo.style.lineCap as CanvasLineCap\n  ctx.lineJoin = pathInfo.style.lineJoin as CanvasLineJoin\n\n  ctx.beginPath()\n  pathInfo.d.forEach((p, i) => {\n    if (i === 0) {\n      ctx.moveTo(p.x, p.y)\n    } else {\n      ctx.lineTo(p.x, p.y)\n    }\n  })\n  ctx.closePath()\n\n  if (pathInfo.included) {\n    pathInfo.included.forEach((poly) => {\n      poly.forEach((p, i) => {\n        if (i === 0) {\n          ctx.moveTo(p.x, p.y)\n        } else {\n          ctx.lineTo(p.x, p.y)\n        }\n      })\n      ctx.closePath()\n    })\n  }\n\n  if (pathInfo.style.fill) {\n    ctx.fillStyle = pathInfo.style.fillStyle\n    ctx.globalAlpha = pathInfo.style.fillGlobalAlpha\n    ctx.fill()\n  }\n\n    // 枠\n  if (pathInfo.style.stroke) {\n    ctx.strokeStyle = pathInfo.style.strokeStyle\n    ctx.globalAlpha = pathInfo.style.strokeGlobalAlpha\n    ctx.lineWidth = pathInfo.style.lineWidth\n    ctx.setLineDash(pathInfo.style.lineDash)\n    ctx.stroke()\n  }\n  ctx.globalAlpha = 1\n}\n\n/**\n * 矩形に収まるよう調整\n * @param pathInfoList パス情報リスト\n * @param x 矩形x座標\n * @param y 矩形y座標\n * @param width 矩形width\n * @param height 矩形height\n * @return 調整後パス情報リスト\n */\nexport function fitRect (\n  pathInfoList: ISvgPath[],\n  x: number,\n  y: number,\n  width: number,\n  height: number\n): ISvgPath[] {\n  let minX: number = Infinity\n  let maxX: number = -Infinity\n  let minY: number = Infinity\n  let maxY: number = -Infinity\n  pathInfoList.forEach((info) => {\n    info.d.forEach((p) => {\n      minX = Math.min(minX, p.x)\n      maxX = Math.max(maxX, p.x)\n      minY = Math.min(minY, p.y)\n      maxY = Math.max(maxY, p.y)\n    })\n  })\n\n  // 原点基準に移動\n  const fromBaseList = pathInfoList.map((info) => ({\n    ...info,\n    d: info.d.map((p) => ({ x: p.x - minX, y: p.y - minY }))\n  }))\n  // 伸縮\n  const orgWidth = maxX - minX\n  const orgHeight = maxY - minY\n  const rateX = width / orgWidth\n  const rateY = height / orgHeight\n  const rate = Math.min(rateX, rateY)\n  const scaledList = fromBaseList.map((info) => ({\n    ...info,\n    d: info.d.map((p) => ({ x: p.x * rate, y: p.y * rate }))\n  }))\n  // 矩形位置に移動\n  const difX = x + (width - orgWidth * rate) / 2\n  const difY = y + (height - orgHeight * rate) / 2\n  const convertedList: ISvgPath[] = scaledList.map((info) => ({\n    ...info,\n    d: info.d.map((p) => ({ x: p.x + difX, y: p.y + difY })),\n    included: (info.included || []).map((poly: IVec2[]) => {\n      return poly.map((p) => ({ x: (p.x - minX) * rate + difX, y: (p.y - minY) * rate + difY }))\n    })\n  }))\n\n  return convertedList\n}\n\n/**\n * SVG文字列から図形のパス情報を取得する\n * 対応タグ: path,rect,ellipse,circle\n * @param svgString SVGリソース文字列\n * @return パス情報リスト\n */\nexport function parseSvgGraphicsStr (svgString: string): ISvgPath[] {\n  const domParser = new DOMParser()\n  const svgDom = domParser.parseFromString(svgString, 'image/svg+xml')\n  const svgTags = svgDom.getElementsByTagName('svg')\n  if (!svgTags || svgTags.length === 0) return []\n  return parseSvgGraphics(svgTags[0] as SVGElement)\n}\n\n/**\n * SVGタグから図形のパス情報を取得する\n * 対応タグ: path,rect,ellipse,circle\n * @param svgTag SVGタグ\n * @return パス情報リスト\n */\nexport function parseSvgGraphics (svgTag: SVGElement): ISvgPath[] {\n  const ret: ISvgPath[] = []\n\n  // パス\n  const tagPathList = svgTag.getElementsByTagName('path')\n  for (let i = 0; i < tagPathList.length; i++) {\n    const elm = tagPathList[i] as SVGPathElement\n    ret.push({\n      d: parsePath(elm),\n      style:  parseTagStyle(elm)\n    })\n  }\n\n  // 矩形\n  const tagRectList = svgTag.getElementsByTagName('rect')\n  for (let i = 0; i < tagRectList.length; i++) {\n    const elm = tagRectList[i] as SVGRectElement\n    ret.push({\n      d : parseRect(elm),\n      style : parseTagStyle(elm)\n    })\n  }\n\n  // 楕円\n  const tagEllipseList = svgTag.getElementsByTagName('ellipse')\n  for (let i = 0; i < tagEllipseList.length; i++) {\n    const elm = tagEllipseList[i] as SVGEllipseElement\n    ret.push({\n      d : parseEllipse(elm),\n      style : parseTagStyle(elm)\n    })\n  }\n\n  // 円\n  const tagCircleList = svgTag.getElementsByTagName('circle')\n  for (let i = 0; i < tagCircleList.length; i++) {\n    const elm = tagCircleList[i] as SVGCircleElement\n    ret.push({\n      d : parseCircle(elm),\n      style : parseTagStyle(elm)\n    })\n  }\n\n  // gタグ→「getElementsByTagName」は子孫全検索なので再帰必要なし\n\n  return ret\n}\n\n/**\n * opentype.jsのpath.commandをd文字列に変換する\n * @param fontPath opentype.jsのpath.command\n * @return d文字列\n */\nexport function openCommandToD (command: any): string {\n  let d: string = command.type\n  if ('x1' in command) d += ` ${command.x1}`\n  if ('y1' in command) d += ` ${command.y1}`\n  if ('x2' in command) d += ` ${command.x2}`\n  if ('y2' in command) d += ` ${command.y2}`\n  if ('x3' in command) d += ` ${command.x3}`\n  if ('y3' in command) d += ` ${command.y3}`\n  if ('x' in command) d += ` ${command.x}`\n  if ('y' in command) d += ` ${command.y}`\n  return d\n}\n\n/**\n * opentype.jsのpathを解析する\n * @param fontPath opentype.jsのpath\n * @return パス情報リスト\n */\nexport function parseOpenPath (fontPath: { commands: any[] }): ISvgPath[] {\n  const pathInfoList: ISvgPath[] = []\n  let current: string = ''\n  fontPath.commands.forEach((c: any) => {\n    current += openCommandToD(c) + ' '\n    if (current && c.type.toUpperCase() === 'Z') {\n      const pathList = parsePathD(current)\n      pathInfoList.push({\n        d: pathList,\n        style:  { ...createStyle(), fill: true, fillStyle: 'black', stroke: false }\n      })\n      current = ''\n    }\n  })\n  return pathInfoList\n}\n\n/**\n * pathタグを解析する\n * @param dStr SVGのpathタグd文字列\n * @return 座標リスト\n */\nexport function parsePathD (dStr: string): IVec2[] {\n  let ret: IVec2[] = []\n\n  // d属性分解\n  const elementList: string[][] = splitD(dStr)\n\n  // 前回座標\n  let pastVec: IVec2 = { x: 0, y: 0 }\n  // 前回制御点\n  let pastControlVec: IVec2 = { x: 0,y: 0 }\n  elementList.forEach((current) => {\n    let pList: IVec2[] = []\n\n    let b0: IVec2 | null = null\n    let b1: IVec2 | null = null\n    let b2: IVec2 | null = null\n    let b3: IVec2 | null = null\n\n    switch (current[0]) {\n      case 'M':\n      case 'L':\n        // 直線(絶対)\n        pList.push({ x: parseFloat(current[1]), y: parseFloat(current[2]) })\n        break\n      case 'm':\n      case 'l':\n        // 直線(相対)\n        pList.push({ x: pastVec.x + parseFloat(current[1]), y: pastVec.y + parseFloat(current[2]) })\n        break\n      case 'H':\n        // 水平(絶対)\n        pList.push({ x: parseFloat(current[1]), y: pastVec.y })\n        break\n      case 'V':\n        // 垂直(絶対)\n        pList.push({ x: pastVec.x, y: parseFloat(current[1]) })\n        break\n      case 'h':\n        // 垂直(相対)\n        pList.push({ x: pastVec.x + parseFloat(current[1]), y: pastVec.y })\n        break\n      case 'v':\n        // 垂直(相対)\n        pList.push({ x: pastVec.x, y: pastVec.y + parseFloat(current[1]) })\n        break\n      case 'Q' :\n        // 制御点準備\n        b0 = pastVec\n        b1 = {\n          x: parseFloat(current[1]),\n          y: parseFloat(current[2])\n        }\n        b2 = {\n          x: parseFloat(current[3]),\n          y: parseFloat(current[4])\n        }\n        // 近似\n        pList = geo.approximateBezier([b0, b1, b2], configs.bezierSplitSize)\n        // 始点は前回点なので除去\n        pList.shift()\n        break\n      case 'q' :\n        // 制御点準備\n        b0 = pastVec\n        b1 = {\n          x : b0.x + parseFloat(current[1]),\n          y : b0.y + parseFloat(current[2])\n        }\n        b2 = {\n          x : b0.x + parseFloat(current[3]),\n          y : b0.y + parseFloat(current[4])\n        }\n        // 近似\n        pList = geo.approximateBezier([b0, b1, b2], configs.bezierSplitSize)\n        // 始点は前回点なので除去\n        pList.shift()\n        break\n      case 'T' :\n        // 制御点準備\n        b0 = pastVec\n        b1 = geo.getSymmetry(b0, pastControlVec)\n        b2 = {\n          x : parseFloat(current[1]),\n          y : parseFloat(current[2])\n        }\n        // 近似\n        pList = geo.approximateBezier([b0, b1, b2], configs.bezierSplitSize)\n        // 始点は前回点なので除去\n        pList.shift()\n        break\n      case 't' :\n        // 制御点準備\n        b0 = pastVec\n        b1 = geo.getSymmetry(b0, pastControlVec)\n        b2 = {\n          x : b0.x + parseFloat(current[1]),\n          y : b0.y + parseFloat(current[2])\n        }\n        // 近似\n        pList = geo.approximateBezier([b0, b1, b2], configs.bezierSplitSize)\n        // 始点は前回点なので除去\n        pList.shift()\n        break\n      case 'C' :\n        // 制御点準備\n        b0 = pastVec\n        b1 = {\n          x : parseFloat(current[1]),\n          y : parseFloat(current[2])\n        }\n        b2 = {\n          x : parseFloat(current[3]),\n          y : parseFloat(current[4])\n        }\n        b3 = {\n          x : parseFloat(current[5]),\n          y : parseFloat(current[6])\n        }\n        // 近似\n        pList = geo.approximateBezier([b0, b1, b2, b3], configs.bezierSplitSize)\n        // 始点は前回点なので除去\n        pList.shift()\n        break\n      case 'c' :\n        // 制御点準備\n        b0 = pastVec\n        b1 = {\n          x : b0.x + parseFloat(current[1]),\n          y : b0.y + parseFloat(current[2])\n        }\n        b2 = {\n          x : b0.x + parseFloat(current[3]),\n          y : b0.y + parseFloat(current[4])\n        }\n        b3 = {\n          x : b0.x + parseFloat(current[5]),\n          y : b0.y + parseFloat(current[6])\n        }\n        // 近似\n        pList = geo.approximateBezier([b0, b1, b2, b3], configs.bezierSplitSize)\n        // 始点は前回点なので除去\n        pList.shift()\n        break\n      case 'S' :\n        // 制御点準備\n        b0 = pastVec\n        b1 = geo.getSymmetry(b0, pastControlVec)\n        b2 = {\n          x : parseFloat(current[1]),\n          y : parseFloat(current[2])\n        }\n        b3 = {\n          x : parseFloat(current[3]),\n          y : parseFloat(current[4])\n        }\n        // 近似\n        pList = geo.approximateBezier([b0, b1, b2, b3], configs.bezierSplitSize)\n        // 始点は前回点なので除去\n        pList.shift()\n        break\n      case 's' :\n        // 制御点準備\n        b0 = pastVec\n        b1 = geo.getSymmetry(b0, pastControlVec)\n        b2 = {\n          x : b0.x + parseFloat(current[1]),\n          y : b0.y + parseFloat(current[2])\n        }\n        b3 = {\n          x : b0.x + parseFloat(current[3]),\n          y : b0.y + parseFloat(current[4])\n        }\n        // 近似\n        pList = geo.approximateBezier([b0, b1, b2, b3], configs.bezierSplitSize)\n        // 始点は前回点なので除去\n        pList.shift()\n        break\n      case 'A':\n        b0 = pastVec\n        b1 = {\n          x : parseFloat(current[6]),\n          y : parseFloat(current[7])\n        }\n\n        pList = geo.approximateArcWithPoint(\n          parseFloat(current[1]),\n          parseFloat(current[2]),\n          b0,\n          b1,\n          !!parseInt(current[4], 10),\n          !!parseInt(current[5], 10),\n          parseFloat(current[3]) / 180 * Math.PI,\n          configs.bezierSplitSize\n        )\n        // 始点は前回点なので除去\n        pList.shift()\n        break\n      case 'a':\n        b0 = pastVec\n        b1 = {\n          x : b0.x + parseFloat(current[6]),\n          y : b0.y + parseFloat(current[7])\n        }\n\n        pList = geo.approximateArcWithPoint(\n          parseFloat(current[1]),\n          parseFloat(current[2]),\n          b0,\n          b1,\n          !!parseInt(current[4], 10),\n          !!parseInt(current[5], 10),\n          parseFloat(current[3]) / 180 * Math.PI,\n          configs.bezierSplitSize\n        )\n        // 始点は前回点なので除去\n        pList.shift()\n        break\n    }\n\n    if (pList.length > 0) {\n      pastVec = pList[pList.length - 1]\n      ret = ret.concat(pList)\n\n      if (pList.length > 1) {\n        // 前回制御点記録\n        pastControlVec = pList[pList.length - 2]\n      }\n    }\n  })\n\n  return ret\n}\n\n/**\n * pathタグを解析する\n * @param svgPath SVGのpathタグDOM\n * @return 座標リスト\n */\nexport function parsePath (svgPath: SVGPathElement): IVec2[] {\n  const dStr = svgPath.getAttribute('d')\n  if (!dStr) return []\n\n  return adoptTransform(svgPath.getAttribute('transform'), parsePathD(dStr))\n}\n\n/**\n * rectタグを解析する\n * @param SVGのrectタグDOM\n * @return 座標リスト\n */\nexport function parseRect (svgRect: SVGRectElement): IVec2[] {\n  let ret = []\n\n  const x = parseFloat(svgRect.getAttribute('x') || '0')\n  const y = parseFloat(svgRect.getAttribute('y') || '0')\n  const width = parseFloat(svgRect.getAttribute('width') || '0')\n  const height = parseFloat(svgRect.getAttribute('height') || '0')\n\n  ret.push({ x, y })\n  ret.push({ x : x + width, y })\n  ret.push({ x : x + width, y : y + height })\n  ret.push({ x, y : y + height })\n\n  // トランスフォーム\n  ret = adoptTransform(svgRect.getAttribute('transform'), ret)\n\n  return ret\n}\n\n/**\n * ellipseタグを解析する\n * @param svgEllipse SVGのellipseタグDOM\n * @return 座標リスト\n */\nexport function parseEllipse (svgEllipse: SVGEllipseElement): IVec2[] {\n  let ret = []\n\n  const cx = parseFloat(svgEllipse.getAttribute('cx') || '0')\n  const cy = parseFloat(svgEllipse.getAttribute('cy') || '0')\n  const rx = parseFloat(svgEllipse.getAttribute('rx') || '1')\n  const ry = parseFloat(svgEllipse.getAttribute('ry') || '1')\n\n  ret = geo.approximateArc(\n    rx, ry,\n    0, Math.PI * 2,\n    { x: cx,y: cy },\n    0, configs.ellipseSplitSize\n  )\n\n  // トランスフォーム\n  ret = adoptTransform(svgEllipse.getAttribute('transform'), ret)\n  return ret\n}\n\n/**\n * circleタグを解析する\n * @param svgCircle  SVGのcircleタグDOM\n * @return 座標リスト\n */\nexport function parseCircle (svgCircle: SVGCircleElement): IVec2[] {\n  let ret = []\n  const cx = parseFloat(svgCircle.getAttribute('cx') || '0')\n  const cy = parseFloat(svgCircle.getAttribute('cy') || '0')\n  const r = parseFloat(svgCircle.getAttribute('r') || '1')\n\n  // 近似方法は楕円と同様\n  ret = geo.approximateArc(\n    r, r,\n    0, Math.PI * 2,\n    { x: cx,y: cy },\n    0, configs.ellipseSplitSize\n  )\n\n  // トランスフォーム\n  ret = adoptTransform(svgCircle.getAttribute('transform'), ret)\n  return ret\n}\n\n/**\n * transformを行う\n * @param commandStr コマンド文字列\n * @param points 変換前座標リスト\n * @return 変形後座標リスト\n */\nexport function adoptTransform (commandStr: string | null, points: IVec2[]): IVec2[] {\n  if (!commandStr) return points\n\n  let ret: IVec2[] = geo.cloneVectors(points)\n  // 複数コマンドの場合もあるのでループ\n  const commandList = commandStr.split(/\\)/)\n  commandList.forEach((current) => {\n    const tmp = current.split(/\\(/)\n    if (tmp.length === 2) {\n      const command = tmp[0]\n      const params: number[] = []\n      tmp[1].split(/,/).forEach((str) => params.push(parseFloat(str)))\n\n      switch (command.trim().toLowerCase()) {\n        case 'matrix':\n          ret = geo.transform(ret, params)\n          break\n        case 'translate':\n          ret = ret.map((p) => ({\n            x: p.x + params[0],\n            y: p.y + params[1]\n          }))\n          break\n        case 'scale':\n          const scaleX = params[0]\n          // XY等倍の場合を考慮\n          let scaleY = params[0]\n          if (params.length > 1) {\n            scaleY = params[1]\n          }\n          ret = ret.map((p) => ({\n            x: p.x * scaleX,\n            y: p.y * scaleY\n          }))\n          break\n        case 'rotate':\n        // 回転基準点\n          let base: IVec2 = { x: 0, y: 0 }\n          if (params.length > 2) {\n            base = { x : params[1], y : params[2] }\n          }\n          ret = ret.map((p) => geo.rotate(p, params[0] * Math.PI / 180, base))\n          break\n        case 'skewx':\n          ret = ret.map((p) => ({\n            x: p.x + Math.tan(params[0] * Math.PI / 180) * p.y,\n            y: p.y\n          }))\n          break\n        case 'skewy':\n          ret = ret.map((p) => ({\n            x: p.x,\n            y: p.y + Math.tan(params[0] * Math.PI / 180) * p.x\n          }))\n          break\n      }\n    }\n  })\n\n  return ret\n}\n\n/**\n * pathタグd属性文字列を分割する\n * @param dString pathのd要素文字列\n * @return コマンド単位の情報配列の配列\n */\nexport function splitD (dString: string): string[][] {\n  // 全コマンドリスト(BbRr非対応)\n  const allCommand = /M|m|L|l|H|h|V|v|C|c|S|s|Q|q|T|t|A|a|Z|z/g\n  // 要素分割\n  const strList = dString.replace(allCommand, ' $& ').split(/,| /).filter((str) => str)\n  // 直前のコマンド\n  let pastCommand = 'M'\n\n  const ret = []\n  for (let i = 0; i < strList.length;) {\n    let info = []\n    // コマンドがあるか？\n    if (strList[i].match(allCommand)) {\n      // あるので回収\n      info[0] = strList[i].trim()\n      pastCommand = info[0]\n      // 進む\n      i++\n    } else {\n      // 前回同様\n      info[0] = pastCommand\n    }\n\n    // 情報数で場合分け\n    if (info[0].match(/Z|z/)) {\n      // 0つ\n    } else if (info[0].match(/V|v|H|h/)) {\n      // 1つ\n      info = info.concat(strList.slice(i, i + 1))\n      i += 1\n    } else if (info[0].match(/M|m|L|l|T|t/)) {\n      // 2つ\n      info = info.concat(strList.slice(i, i + 2))\n      i += 2\n    } else if (info[0].match(/Q|q|S|s/)) {\n      // 4つ\n      info = info.concat(strList.slice(i, i + 4))\n      i += 4\n    } else if (info[0].match(/C|c/)) {\n      // 6つ\n      info = info.concat(strList.slice(i, i + 6))\n      i += 6\n    } else if (info[0].match(/A|a/)) {\n      // 7つ\n      info = info.concat(strList.slice(i, i + 7))\n      i += 7\n    } else {\n      // 不適\n      break\n    }\n\n    ret.push(info)\n  }\n\n  return ret\n}\n\n/**\n * svg文字列を生成する\n * @param pathList path情報リスト\n * @return xml文字列\n */\nexport function serializeSvgString (pathList: ISvgPath[]): string {\n  const svg = serializeSvg(pathList)\n  const xmlSerializer = new XMLSerializer()\n  const textXml = xmlSerializer.serializeToString(svg)\n  return textXml\n}\n\n/**\n * svgタグを生成する\n * @param pathList path情報リスト\n * @return svgタグ\n */\nexport function serializeSvg (pathList: ISvgPath[]): SVGElement {\n  const dom = document.createElementNS('http://www.w3.org/2000/svg', 'svg')\n\n  // キャンバスサイズ\n  let width = 1\n  let height = 1\n\n  pathList.forEach((path) => {\n    dom.appendChild(serializePath(path.d, path.style))\n    path.d.forEach((p) => {\n      width = Math.max(width, p.x)\n      height = Math.max(height, p.y)\n    })\n  })\n\n  width *= 1.1\n  height *= 1.1\n\n  dom.setAttribute('width', `${width}`)\n  dom.setAttribute('height', `${height}`)\n\n  return dom\n}\n\n/**\n * pathタグを生成する\n * @param pointList 座標リスト\n * @param style スタイル情報\n * @return pathタグ\n */\nexport function serializePath (pointList: IVec2[], style: ISvgStyle): SVGPathElement {\n  const dom = document.createElementNS('http://www.w3.org/2000/svg', 'path')\n  dom.setAttribute('d', serializePointList(pointList))\n  dom.setAttribute('style', serializeStyle(style))\n  return dom\n}\n\n/**\n * 座標リストをd属性文字列に変換する\n * @param pointList 座標リスト\n * @return d属性文字列\n */\nexport function serializePointList (pointList: IVec2[]): string {\n  let ret = ''\n\n  pointList.forEach((p, i) => {\n    if (i === 0) {\n      ret += 'M ' + p.x + ',' + p.y\n    } else {\n      ret += ' L ' + p.x + ',' + p.y\n      if (i === pointList.length - 1) {\n        ret += ' Z'\n      }\n    }\n  })\n\n  return ret\n}\n\n/**\n * デフォルトstyle作成\n * @return スタイルオブジェクト\n */\nexport function createStyle () {\n  return {\n    fill: false,\n    fillGlobalAlpha: 1,\n    fillStyle: '',\n    lineCap: 'butt',\n    lineDash: [],\n    lineJoin: 'bevel',\n    lineWidth: 1,\n    stroke: false,\n    strokeGlobalAlpha: 1,\n    strokeStyle: ''\n  }\n}\n\n/**\n * pathタグのスタイルを取得する\n * @param svgPath SVGのpathタグDOM\n * @return スタイルオブジェクト\n */\nexport function parseTagStyle (svgPath: SVGElement): ISvgStyle {\n  const ret: ISvgStyle = createStyle()\n\n  // スタイル候補要素リスト\n  const styleObject: any = {}\n\n  const styleAttr = svgPath.getAttributeNode('style')\n  if (!styleAttr) {\n    // 要素から直接取得\n    svgPath.getAttributeNames().forEach((name) => {\n      const attr = svgPath.getAttributeNode(name)\n      if (!attr) return\n      styleObject[attr.name] = attr.value\n    })\n  } else {\n    // style要素から取得\n    const styleStr = styleAttr.value\n    styleStr.split(';').forEach((elem: string) => {\n      const splited = elem.split(':')\n      if (splited.length !== 2) return\n      styleObject[splited[0].trim()] = splited[1].trim()\n    })\n  }\n\n  Object.keys(styleObject).forEach((key) => {\n    key = key.toLowerCase()\n    const val = styleObject[key]\n\n    if (key === 'fill') {\n      if (val === 'none') {\n        ret.fillStyle = ''\n        ret.fill = false\n      } else {\n        ret.fillStyle = val\n        ret.fill = true\n      }\n    } else if (key === 'stroke') {\n      if (val === 'none') {\n        ret.strokeStyle = ''\n        ret.stroke = false\n      } else {\n        ret.strokeStyle = val\n        ret.stroke = true\n      }\n    } else if (key === 'stroke-width') {\n      ret.lineWidth = parseFloat(val)\n    } else if (key === 'stroke-opacity') {\n      ret.strokeGlobalAlpha = parseFloat(val)\n    } else if (key === 'fill-opacity') {\n      ret.fillGlobalAlpha = parseFloat(val)\n    } else if (key === 'stroke-linecap') {\n      ret.lineCap = val\n    } else if (key === 'stroke-linejoin') {\n      ret.lineJoin = val\n    } else if (key === 'stroke-dasharray') {\n      if (val.toLowerCase() === 'none') {\n        ret.lineDash = []\n      } else {\n        const strArray = val.split(',')\n        ret.lineDash = []\n        strArray.forEach((str: string) => {\n          ret.lineDash.push(parseFloat(str))\n        })\n      }\n    } else {\n      // 無視\n    }\n  })\n\n  return ret\n}\n\n/**\n * スタイル情報をstyle属性文字列に変換する\n * @method serializeStyle\n * @param style スタイル情報\n * @return style属性文字列\n */\nexport function serializeStyle (style: ISvgStyle) {\n  let ret = ''\n\n  // fill情報\n  if (!style.fill) {\n    ret += 'fill:none;'\n  } else {\n    ret += 'fill:' + style.fillStyle + ';'\n  }\n  if (style.fillGlobalAlpha) {\n    ret += 'fill-opacity:' + style.fillGlobalAlpha + ';'\n  }\n\n  // stroke情報\n  if (!style.stroke) {\n    ret += 'stroke:none;'\n  } else {\n    ret += 'stroke:' + style.strokeStyle + ';'\n  }\n  if (style.lineWidth) {\n    ret += 'stroke-width:' + style.lineWidth + ';'\n  }\n  if (style.strokeGlobalAlpha) {\n    ret += 'stroke-opacity:' + style.strokeGlobalAlpha + ';'\n  }\n  if (style.lineCap) {\n    ret += 'stroke-linecap:' + style.lineCap + ';'\n  }\n  if (style.lineJoin) {\n    ret += 'stroke-linejoin:' + style.lineJoin + ';'\n  }\n  if (style.lineDash) {\n    if (style.lineDash.length > 0) {\n      ret += 'stroke-dasharray:' + style.lineDash.join(',') + ';'\n    } else {\n      ret += 'stroke-dasharray:none;'\n    }\n  }\n\n  return ret\n}\n","import * as _geo from './geo'\nimport * as _svg from './svg'\n\nexport const geo = _geo\nexport const svg = _svg\n\nexport default {\n  geo,\n  svg\n}\n"]}