{"version":3,"sources":["../src/geo.ts","../src/svg.ts","main.ts"],"names":[],"mappings":"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","file":"main.346a2623.js","sourceRoot":"../demo","sourcesContent":["import { IVec2, IRectangle, AffineMatrix } from './types'\n\nexport const MINVALUE: number = 0.000001\n\nexport const IDENTITY_AFFINE: AffineMatrix = [1, 0, 0, 1, 0, 0]\n\nexport function vec(x: number, y: number): IVec2 {\n  return { x, y }\n}\n\nexport function add(a: IVec2, b: IVec2): IVec2 {\n  return vec(a.x + b.x, a.y + b.y)\n}\n\nexport function sub(a: IVec2, b: IVec2): IVec2 {\n  return vec(a.x - b.x, a.y - b.y)\n}\n\nexport function multi(a: IVec2, b: number): IVec2 {\n  return vec(a.x * b, a.y * b)\n}\n\nexport function isSame(a: IVec2, b: IVec2): boolean {\n  const dif: IVec2 = sub(a, b)\n  return Math.abs(dif.x) < MINVALUE && Math.abs(dif.y) < MINVALUE\n}\n\nexport function getDistance(a: IVec2, b: IVec2): number {\n  return getNorm(sub(a, b))\n}\n\nexport function getPolylineLength(polyline: IVec2[], closed = false): number {\n  if (polyline.length < 2) return 0\n\n  let ret = 0\n  for (let i = 0; i < polyline.length - 1; i++) {\n    ret += getDistance(polyline[i], polyline[i + 1])\n  }\n  if (closed) {\n    ret += getDistance(polyline[polyline.length - 1], polyline[0])\n  }\n  return ret\n}\n\nexport function getNorm(a: IVec2): number {\n  return Math.sqrt(a.x * a.x + a.y * a.y)\n}\n\nexport function isZero(a: IVec2): boolean {\n  return getNorm(a) < MINVALUE\n}\n\nexport function getUnit(a: IVec2): IVec2 {\n  const d = getNorm(a)\n  if (d < MINVALUE) throw new Error('cannot get unit vector of zero vector')\n  return multi(a, 1 / d)\n}\n\nexport function getCross(a: IVec2, b: IVec2): number {\n  return a.x * b.y - a.y * b.x\n}\n\nexport function getInner(a: IVec2, b: IVec2): number {\n  return a.x * b.x + a.y * b.y\n}\n\nexport function cloneVectors(vectors: IVec2[]): IVec2[] {\n  return vectors.map((v) => ({ ...v }))\n}\n\nexport function getCenter(a: IVec2, b: IVec2): IVec2 {\n  return multi(add(a, b), 1 / 2)\n}\n\nexport function getRectCenter(rec: IRectangle): IVec2 {\n  return vec(rec.x + rec.width / 2, rec.y + rec.height / 2)\n}\n\nexport function getPolygonCenter(polygon: IVec2[]): IVec2 {\n  if (polygon.length === 0) return vec(0, 0)\n\n  return multi(\n    polygon.reduce((p, c) => add(p, c), vec(0, 0)),\n    1 / polygon.length\n  )\n}\n\nexport function getRadian(a: IVec2, from: IVec2 = vec(0, 0)): number {\n  const dif = sub(a, from)\n  return Math.atan2(dif.y, dif.x)\n}\n\n/**\n * fromに対して、aと点対称なベクトル取得\n * @param a 対象ベクトル\n * @param from 基点\n * @param 点対称ベクトル\n */\nexport function getSymmetry(a: IVec2, from: IVec2 = vec(0, 0)): IVec2 {\n  return add(multi(sub(from, a), 2), a)\n}\n\n/**\n * fromに対して、aからradian回転したベクトル取得\n * @param a 対象ベクトル\n * @param radian 回転ラジアン\n * @param from 基点\n * @param 回転後のベクトル\n */\nexport function rotate(\n  a: IVec2,\n  radian: number,\n  from: IVec2 = vec(0, 0)\n): IVec2 {\n  const fromBase = sub(a, from)\n  const s = Math.sin(radian)\n  const c = Math.cos(radian)\n  return add(\n    vec(c * fromBase.x - s * fromBase.y, s * fromBase.x + c * fromBase.y),\n    from\n  )\n}\n\nfunction getRotateFn(\n  radian: number,\n  from: IVec2 = vec(0, 0)\n): (a: IVec2, reverse?: boolean) => IVec2 {\n  const s = Math.sin(radian)\n  const c = Math.cos(radian)\n  return (a, reverse) => {\n    const fromBase = sub(a, from)\n    return reverse\n      ? add(\n          vec(\n            c * fromBase.x + s * fromBase.y,\n            -s * fromBase.x + c * fromBase.y\n          ),\n          from\n        )\n      : add(\n          vec(c * fromBase.x - s * fromBase.y, s * fromBase.x + c * fromBase.y),\n          from\n        )\n  }\n}\n\n/**\n * 2次方程式の解の公式\n * a * x^2 + b * x + c = 0\n * 解に虚数が含まれる場合は解なし扱い\n * @param a x^2の係数\n * @param b xの係数\n * @param c 定数\n * @return 解の配列\n */\nexport function solveEquationOrder2(a: number, b: number, c: number): number[] {\n  if (isCloseToZero(a)) {\n    return isCloseToZero(b) ? [] : [-c / b]\n  }\n\n  const d = b * b - 4 * a * c\n  if (d < 0) {\n    return []\n  }\n\n  const ia = 0.5 / a\n\n  if (isCloseToZero(d)) {\n    return [-b * ia]\n  }\n\n  const sd = Math.sqrt(d)\n  return [(-b + sd) * ia, (-b - sd) * ia]\n}\n\n/**\n * 点から直線への垂線の足\n * @param p 対象の点\n * @param line 直線\n * @return 垂線の足\n */\nexport function getPedal(p: IVec2, line: IVec2[]): IVec2 {\n  if (line.length !== 2) throw new Error('line must be length = 2')\n  const s = line[0]\n  const t = line[1]\n  const vecST = sub(t, s)\n  const vecSP = sub(p, s)\n  const inner = getInner(vecST, vecSP)\n  const rate = inner / getInner(vecST, vecST)\n  return add(s, multi(vecST, rate))\n}\n\n/**\n * 2次ベジェ曲線と直線の当たり判定用パラメータを取得する\n * @param p0 ベジェ曲線始点\n * @param p1 ベジェ曲線制御点\n * @param p2 ベジェ曲線終点\n * @param p 直線始点\n * @param q 直線終点\n * @return ベジェ曲線パラメータ配列\n */\nfunction rayToBezier(\n  p0: IVec2,\n  p1: IVec2,\n  p2: IVec2,\n  p: IVec2,\n  q: IVec2\n): number[] {\n  const vx: number = q.x - p.x\n  const vy: number = q.y - p.y\n  const a: number = p0.x - 2 * p1.x + p2.x\n  const b: number = 2 * (p1.x - p0.x)\n  const c: number = p0.x\n  const d: number = p0.y - 2 * p1.y + p2.y\n  const e: number = 2 * (p1.y - p0.y)\n  const f: number = p0.y\n\n  return solveEquationOrder2(\n    a * vy - vx * d,\n    b * vy - vx * e,\n    vy * c - vy * p.x - vx * f + vx * p.y\n  )\n}\n\n/**\n * 2次ベジェ曲「線分」と「直線」の交点を取得する\n * @method crossLineAndBezier\n * @param p0 ベジェ曲線始点\n * @param p1 ベジェ曲線制御点\n * @param p2 ベジェ曲線終点\n * @param p 直線始点\n * @param q 直線終点\n * @return 交点リスト\n */\nexport function getCrossLineAndBezier(\n  p0: IVec2,\n  p1: IVec2,\n  p2: IVec2,\n  p: IVec2,\n  q: IVec2\n) {\n  return rayToBezier(p0, p1, p2, p, q)\n    .filter((t) => 0 <= t && t <= 1)\n    .map((t) =>\n      vec(\n        (p2.x - 2 * p1.x + p0.x) * t * t + 2 * (p1.x - p0.x) * t + p0.x,\n        (p2.y - 2 * p1.y + p0.y) * t * t + 2 * (p1.y - p0.y) * t + p0.y\n      )\n    )\n}\n\n/**\n * 線分と線分の交差判定（端点での接触は含まない）\n * @param seg1 線分1\n * @param seg2 線分2\n * @return 交差しているフラグ\n */\nexport function isCrossSegAndSeg(seg1: IVec2[], seg2: IVec2[]): boolean {\n  const { ta, tb, tc, td } = getCrossSegAndSegParams(seg1, seg2)\n  return tc * td < 0 && ta * tb < 0\n}\n\n/**\n * 線分と線分の接触判定（端点での接触含む）\n * @param seg1 線分1\n * @param seg2 線分2\n * @return 接触しているフラグ\n */\nexport function isTouchSegAndSeg(seg1: IVec2[], seg2: IVec2[]): boolean {\n  const { ta, tb, tc, td } = getCrossSegAndSegParams(seg1, seg2)\n  return tc * td <= 0 && ta * tb <= 0\n}\n\nfunction getCrossSegAndSegParams(\n  seg1: IVec2[],\n  seg2: IVec2[]\n): {\n  ta: number\n  tb: number\n  tc: number\n  td: number\n} {\n  const ax = seg1[0].x\n  const ay = seg1[0].y\n  const bx = seg1[1].x\n  const by = seg1[1].y\n  const cx = seg2[0].x\n  const cy = seg2[0].y\n  const dx = seg2[1].x\n  const dy = seg2[1].y\n  const ta = (cx - dx) * (ay - cy) + (cy - dy) * (cx - ax)\n  const tb = (cx - dx) * (by - cy) + (cy - dy) * (cx - bx)\n  const tc = (ax - bx) * (cy - ay) + (ay - by) * (ax - cx)\n  const td = (ax - bx) * (dy - ay) + (ay - by) * (ax - dx)\n  return { ta, tb, tc, td }\n}\n\n/**\n * 平行判定\n * @param a ベクトル or 2点の配列\n * @param b 同上\n * @return 平行であるフラグ\n */\nexport function isParallel(a: IVec2, b: IVec2): boolean {\n  const cross = getCross(a, b)\n  return Math.abs(cross) < MINVALUE\n}\n\n/**\n * 点が直線上にあるか判定\n * @param p 点\n * @param line 直線\n * @return 直線上にあるフラグ\n */\nexport function isOnLine(p: IVec2, line: IVec2[]): boolean {\n  return isZero(sub(p, getPedal(p, line)))\n}\n\n/**\n * 点が線分上にあるか判定\n * @param p 点\n * @param seg 線分\n * @return 線分上にあるフラグ\n */\nexport function isOnSeg(p: IVec2, seg: IVec2[]): boolean {\n  if (!isZero(sub(p, getPedal(p, seg)))) return false\n  const v1 = sub(seg[1], seg[0])\n  const v2 = sub(p, seg[0])\n  if (getInner(v1, v2) < 0) return false\n  if (getNorm(v1) < getNorm(v2)) return false\n  return true\n}\n\n/**\n * 点から正の方向へ伸ばした水平線が線分と交差するか判定\n * 点が面上にあるか判定に利用する\n * 点が線分上の場合はfalse\n * @param p 点\n * @param seg 線分\n * @return 交差するフラグ\n */\nfunction isCrossSegAndRightHorizon(p: IVec2, seg: IVec2[]): boolean {\n  // 平行な場合はfalse\n  if (Math.abs(seg[0].y - seg[1].y) < MINVALUE) {\n    return false\n  }\n\n  // 線分の上側端点との接触はfalse、下側端点との接触はtrueで統一\n  let top, bottom\n  if (seg[0].y < seg[1].y) {\n    ;[bottom, top] = seg\n  } else {\n    ;[top, bottom] = seg\n  }\n  if (p.y < bottom.y || top.y <= p.y) {\n    return false\n  }\n\n  // 交点は厳密にpの右側でなければいけない\n  const cross = getCrossSegAndLine(seg, [p, vec(p.x + 1, p.y)])\n  if (!cross || cross.x <= p.x) {\n    return false\n  }\n\n  return true\n}\n\n/**\n * 点が面上にあるか判定（境界線上を含む）\n * @param p 点\n * @param polygon 面\n * @return 面上にあるフラグ\n */\nexport function isOnPolygon(p: IVec2, polygon: IVec2[]): boolean {\n  // 頂点上判定\n  if (polygon.find((point) => p.x === point.x && p.y === point.y)) return true\n\n  const segs: IVec2[][] = polygon\n    .map((point, i) => {\n      return [point, i < polygon.length - 1 ? polygon[i + 1] : polygon[0]]\n    })\n    // 長さ0の辺は扱わない\n    .filter((seg) => !isSame(seg[0], seg[1]))\n\n  // 辺上判定\n  for (let i = 0; i < segs.length; i++) {\n    const seg = segs[i]\n    if (isOnSeg(p, seg)) {\n      return true\n    }\n  }\n\n  const hitSegs = segs.filter((seg) => isCrossSegAndRightHorizon(p, seg))\n  return hitSegs.length % 2 === 1\n}\n\n/**\n * 線分と直線の交点取得\n * @param seg 線分\n * @param line 直線\n * @return 交点\n */\nexport function getCrossSegAndLine(seg: IVec2[], line: IVec2[]): IVec2 | null {\n  if (isParallel(sub(seg[0], seg[1]), sub(line[0], line[1]))) return null\n  if (isOnLine(seg[0], line)) return { ...seg[0] }\n  if (isOnLine(seg[1], line)) return { ...seg[1] }\n\n  const s1 =\n    ((line[1].x - line[0].x) * (seg[0].y - line[0].y) -\n      (line[1].y - line[0].y) * (seg[0].x - line[0].x)) /\n    2\n  const s2 =\n    ((line[1].x - line[0].x) * (line[0].y - seg[1].y) -\n      (line[1].y - line[0].y) * (line[0].x - seg[1].x)) /\n    2\n  const rate = s1 / (s1 + s2)\n  const isExistCorss = 0 < rate && rate < 1\n\n  return isExistCorss\n    ? vec(\n        seg[0].x + (seg[1].x - seg[0].x) * rate,\n        seg[0].y + (seg[1].y - seg[0].y) * rate\n      )\n    : null\n}\n\n/**\n * 同一線分かを判定する\n * @param ab 線分ab\n * @param cd 線分cd\n * @return 同一であるフラグ\n */\nexport function isSameSeg(ab: IVec2[], cd: IVec2[]): boolean {\n  if (isSame(ab[0], cd[0]) && isSame(ab[1], cd[1])) return true\n  if (isSame(ab[0], cd[1]) && isSame(ab[1], cd[0])) return true\n  return false\n}\n\n/**\n * ポリゴンを直線で分割する\n * @param pol 面\n * @param line 直線\n * @return 分割された点配列の配列\n */\nexport function splitPolyByLine(pol: IVec2[], line: IVec2[]): IVec2[][] {\n  let points: IVec2[] = []\n  let crossIndex: number[] = []\n  let crossList: IVec2[] = []\n\n  pol.forEach((p, i) => {\n    const targetLine = [p, pol[(i + 1) % pol.length]]\n    const cross = getCrossSegAndLine(targetLine, line)\n    points.push(p)\n    if (cross) {\n      points.push(cross)\n      crossIndex.push(i + 1 + crossIndex.length)\n      crossList.push(cross)\n    }\n  })\n\n  if (crossIndex.length % 2 !== 0) return []\n\n  // 近い順に並べる -> 直線をx軸と重なるよう回転してx座標で比較\n  const rad: number = getRadian(line[0], line[1])\n  crossList.sort((a, b) => rotate(a, -rad).x - rotate(b, -rad).x)\n\n  // 面の辺と同一ではないものを採用\n  let targetSection: IVec2[] = []\n  for (let k = 0; k < crossList.length - 1; k += 2) {\n    const section = [crossList[k], crossList[k + 1]]\n    let sameSeg = false\n    for (let l = 0; l < pol.length; l++) {\n      if (isSameSeg(section, [pol[l], pol[(l + 1) % pol.length]])) {\n        sameSeg = true\n        break\n      }\n    }\n\n    if (!sameSeg) {\n      targetSection = section\n      break\n    }\n  }\n\n  if (targetSection.length !== 2) return []\n\n  // 除外対象回収\n  const dropList = crossList.concat()\n  let tmpIndex = dropList.indexOf(targetSection[0])\n  if (tmpIndex !== -1) {\n    dropList.splice(tmpIndex, 1)\n  }\n  tmpIndex = dropList.indexOf(targetSection[1])\n  if (tmpIndex !== -1) {\n    dropList.splice(tmpIndex, 1)\n  }\n  const tmpList = points.concat()\n  dropList.forEach((p) => {\n    const i = tmpList.indexOf(p)\n    tmpList.splice(i, 1)\n  })\n\n  points = tmpList\n  crossList = targetSection\n\n  const i0 = points.indexOf(crossList[0])\n  const i1 = points.indexOf(crossList[1])\n\n  if (i0 === -1 || i1 === -1) return []\n\n  crossIndex = []\n  crossIndex[0] = Math.min(i0, i1)\n  crossIndex[1] = Math.max(i0, i1)\n\n  // 分割ポリゴンを拾い集める\n  const splitedPolygons = []\n\n  // 1つ目\n  let splitPol = []\n  // 交点まで追加\n  for (let i = 0; i <= crossIndex[0]; i++) {\n    splitPol.push(vec(points[i].x, points[i].y))\n  }\n  // 交点から追加\n  for (let i = crossIndex[1]; i < points.length; i++) {\n    splitPol.push(vec(points[i].x, points[i].y))\n  }\n  // 確定\n  splitedPolygons.push(splitPol)\n\n  // 2つ目\n  splitPol = []\n  // 交点から交点まで追加\n  for (let i = crossIndex[0]; i <= crossIndex[1]; i++) {\n    splitPol.push(vec(points[i].x, points[i].y))\n  }\n  // 確定\n  splitedPolygons.push(splitPol)\n\n  // 再帰的に分割\n  const recursiveResult: IVec2[][] = []\n  splitedPolygons.forEach((polygon) => {\n    const splited = splitPolyByLine(polygon, line)\n    if (splited.length === 0) {\n      recursiveResult.push(polygon)\n    } else {\n      recursiveResult.push(...splited)\n    }\n  })\n\n  return recursiveResult\n}\n\n/**\n * 三角分割\n * @param polygon 面\n * @return 分割面リスト\n */\nexport function triangleSplit(polygon: IVec2[]): IVec2[][] {\n  // 時計周りに揃える\n  polygon = convertLoopwise(polygon)\n\n  // ポリゴン複製\n  const targetPoly = omitSamePoint(polygon)\n\n  // 最遠点のインデックス\n  let farthestIndex = 0\n  // 現在の最遠点と前後点で作った三角形の外積\n  let currentCross = 0\n  // 分割後の面リスト\n  const triangleList = []\n\n  // ループ\n  while (targetPoly.length >= 3) {\n    // 最遠点インデックス取得\n    const sorted = targetPoly.concat()\n    sorted.sort((a, b) => {\n      return getNorm(b) - getNorm(a)\n    })\n    farthestIndex = targetPoly.indexOf(sorted[0])\n\n    // 分割実行\n    let tri = getTriangle(targetPoly, farthestIndex)\n    if (!tri) {\n      // 最遠点では失敗\n      const size = targetPoly.length\n      // 外積計算\n      const pa = sub(\n        targetPoly[(farthestIndex + 1) % size],\n        targetPoly[farthestIndex]\n      )\n      const pb = sub(\n        targetPoly[farthestIndex - 1 < 0 ? size - 1 : farthestIndex - 1],\n        targetPoly[farthestIndex]\n      )\n\n      currentCross = getCross(pa, pb)\n\n      let index = farthestIndex\n      // 最遠点以外で探す\n      while (!tri) {\n        index = (index + 1) % size\n        // 最遠点の外積と同じ符号かを判定\n        const v1 = sub(targetPoly[(index + 1) % size], targetPoly[index])\n        const v2 = sub(\n          targetPoly[index - 1 < 0 ? size - 1 : index - 1],\n          targetPoly[index]\n        )\n        const tmpCross = getCross(v1, v2)\n        if (tmpCross * currentCross > 0) {\n          // 判定続行\n          tri = getTriangle(targetPoly, index)\n        }\n        if (index === farthestIndex) {\n          throw new Error('failed to split triangles')\n        }\n      }\n\n      // 採用された点を削除\n      targetPoly.splice(index, 1)\n    } else {\n      // 最遠点削除\n      targetPoly.splice(farthestIndex, 1)\n    }\n    triangleList.push(tri)\n  }\n  return triangleList\n}\n\n/**\n * 面から三角形を取得する\n * @param polygon 面\n * @param index このインデックスの点とその両側の点で三角形を作る\n * @return 三角形、内部に入り込む点がある場合はnull\n */\nfunction getTriangle(polygon: IVec2[], index: number): IVec2[] | null {\n  // indexとその前後点で三角形作成\n  const size = polygon.length\n  const p0 = polygon[index]\n  const p1 = polygon[(index + 1) % size]\n  const p2 = polygon[index - 1 < 0 ? size - 1 : index - 1]\n\n  const tri: IVec2[] = [p0, p1, p2]\n\n  // 内部に点が入り込まないか判定\n  let invalid: boolean = false\n  polygon.some((p) => {\n    if (p !== p0 && p !== p1 && p !== p2) {\n      if (isPointOnTriangle(tri, p)) {\n        // 失敗\n        invalid = true\n      }\n    }\n    return invalid\n  })\n\n  return invalid ? null : tri\n}\n\n/**\n * 点が三角形内にあるかを判定する\n * 境界も含む\n * @param tri 三角形\n * @param p 点\n * @return 内部にあるフラグ\n */\nexport function isPointOnTriangle(tri: IVec2[], p: IVec2): boolean {\n  // 三角形の3つのベクトル\n  const ab = sub(tri[1], tri[0])\n  const bc = sub(tri[2], tri[1])\n  const ca = sub(tri[0], tri[2])\n\n  // 三角形の各点からpへのベクトル\n  const ap = sub(p, tri[0])\n  const bp = sub(p, tri[1])\n  const cp = sub(p, tri[2])\n\n  // 外積を求める\n  const crossABP = getCross(ab, bp)\n  const crossBCP = getCross(bc, cp)\n  const crossCAP = getCross(ca, ap)\n\n  // 外積の符号が全て同じなら内部にある\n  // 0も含む→境界も含む\n  if (\n    (crossABP >= 0 && crossBCP >= 0 && crossCAP >= 0) ||\n    (crossABP <= 0 && crossBCP <= 0 && crossCAP <= 0)\n  ) {\n    return true\n  }\n\n  return false\n}\n\n/**\n * 面を時計回りに変換する\n * @param {vector[]} 面\n * @return 時計回りにした面(引数とは別配列にする)\n */\nexport function convertLoopwise(polygon: IVec2[]): IVec2[] {\n  const ret = polygon.concat()\n  if (getLoopwise(polygon) === -1) {\n    ret.reverse()\n  }\n  return ret\n}\n\n/**\n * 面の座標が時計回りかを判定する\n * @param polygon 面\n * @return -1:反時計 0:不定 1:時計\n */\nexport function getLoopwise(polygon: IVec2[]): number {\n  const area = getArea(polygon, true)\n  if (area > 0) return 1\n  if (area < 0) return -1\n  return 0\n}\n\n/**\n * 面積取得\n * @param polygon 面\n * @param allowNegative 負値を許すフラグ\n * @return 面積\n */\nexport function getArea(\n  polygon: IVec2[],\n  allowNegative: boolean = false\n): number {\n  if (polygon.length < 3) return 0\n\n  let area = 0\n  const size = polygon.length\n  for (let i = 0; i < size - 1; i++) {\n    area +=\n      (polygon[i].x - polygon[i + 1].x) * (polygon[i].y + polygon[i + 1].y)\n  }\n  // 最後分\n  area +=\n    (polygon[size - 1].x - polygon[0].x) * (polygon[size - 1].y + polygon[0].y)\n\n  area /= 2\n\n  // 負値を許さないなら絶対値\n  if (!allowNegative) {\n    area = Math.abs(area)\n  }\n\n  return area\n}\n\n/**\n * ベジェ曲線を直線で近似する(３次まで対応)\n * @param pointList 制御点リスト\n * @param size 分割数(1なら制御点両端のみ)\n * @return 座標リスト\n */\nexport function approximateBezier(pointList: IVec2[], size: number): IVec2[] {\n  const ret: IVec2[] = []\n  const unitT: number = 1 / size\n\n  if (pointList.length === 3) {\n    // ２次ベジェの場合\n    for (let i = 0; i <= size; i++) {\n      ret.push(getPointOnBezier2(pointList as [IVec2, IVec2, IVec2], unitT * i))\n    }\n  } else if (pointList.length === 4) {\n    // 3次ベジェの場合\n    for (let i = 0; i <= size; i++) {\n      ret.push(\n        getPointOnBezier3(pointList as [IVec2, IVec2, IVec2, IVec2], unitT * i)\n      )\n    }\n  } else {\n    throw new Error('connot approximate')\n  }\n\n  return ret\n}\n\n/**\n * get point with the rate on bezier2\n * @param pointList controller points\n * @param rate rate between start point and end point\n * @return calced point\n */\nexport function getPointOnBezier2(\n  pointList: Readonly<[IVec2, IVec2, IVec2]>,\n  rate: number\n): IVec2 {\n  const t = rate\n  const nt = 1 - t\n  const c0 = multi(pointList[0], nt * nt)\n  const c1 = multi(pointList[1], 2 * t * nt)\n  const c2 = multi(pointList[2], t * t)\n  return vec(c0.x + c1.x + c2.x, c0.y + c1.y + c2.y)\n}\n\nexport function getBezier2LerpFn(\n  pointList: Readonly<[IVec2, IVec2, IVec2]>\n): (t: number) => IVec2 {\n  return (t) => getPointOnBezier2(pointList, t)\n}\n\n/**\n * get point with the rate on bezier3\n * @param pointList controller points\n * @param rate rate between start point and end point\n * @return calced point\n */\nexport function getPointOnBezier3(\n  pointList: Readonly<[IVec2, IVec2, IVec2, IVec2]>,\n  rate: number\n): IVec2 {\n  const t = rate\n  const nt = 1 - t\n  const c0 = multi(pointList[0], nt * nt * nt)\n  const c1 = multi(pointList[1], 3 * t * nt * nt)\n  const c2 = multi(pointList[2], 3 * t * t * nt)\n  const c3 = multi(pointList[3], t * t * t)\n  return vec(c0.x + c1.x + c2.x + c3.x, c0.y + c1.y + c2.y + c3.y)\n}\n\nexport function getBezier3LerpFn(\n  pointList: Readonly<[IVec2, IVec2, IVec2, IVec2]>\n): (t: number) => IVec2 {\n  return (t) => getPointOnBezier3(pointList, t)\n}\n\n/**\n * get point with the rate on bezier3\n * need these conditions to get unique value\n * p0.x <= p1.x <= p3.x\n * p0.x <= p2.x <= p3.x\n * or may cause unexpected NaN\n * @param pointList controller points [p0, p1, p2, p3]\n * @param rate rate between start point and end point\n * @return calced point\n */\nexport function getYOnBezier3AtX(\n  pointList: Readonly<[IVec2, IVec2, IVec2, IVec2]>,\n  x: number\n): number {\n  const [p0, p1, p2, p3] = pointList\n  const a = -p0.x + 3 * p1.x - 3 * p2.x + p3.x\n  const b = 3 * p0.x - 6 * p1.x + 3 * p2.x\n  const c = -3 * p0.x + 3 * p1.x\n  const d = p0.x - x\n\n  const t = solveBezier3Fomula(a, b, c, d)\n  const tt = t * t\n  const ttt = tt * t\n  const tm = 1 - t\n  const tmtm = tm * tm\n  const tmtmtm = tmtm * tm\n\n  return tmtmtm * p0.y + 3 * t * tmtm * p1.y + 3 * tt * tm * p2.y + ttt * p3.y\n}\n\n/**\n * 円弧を直線で近似する\n * @param rx x軸半径\n * @param ry y軸半径\n * @param startRadian 開始ラジアン\n * @param endRadian 終了ラジアン\n * @param center 中心座標\n * @param radian 傾き\n * @param size 分割数\n * @return 座標リスト\n */\nexport function approximateArc(\n  rx: number,\n  ry: number,\n  startRadian: number,\n  endRadian: number,\n  center: IVec2,\n  radian: number,\n  size: number\n): IVec2[] {\n  const ret = []\n  const range = endRadian - startRadian\n  const unitT = range / size\n  const rotateFn = getRotateFn(radian)\n\n  for (let i = 0; i <= size; i++) {\n    const t = unitT * i + startRadian - radian\n    ret.push(add(rotateFn(vec(rx * Math.cos(t), ry * Math.sin(t))), center))\n  }\n\n  return ret\n}\n\n/**\n * Approximate arc path as a polyline\n * https://www.w3.org/TR/SVG11/implnote.html#ArcImplementationNotes\n * @method approximateArcWithPoint\n * @param rx x軸半径\n * @param ry y軸半径\n * @param startPoint 開始点\n * @param endPoint 終了点\n * @param largeArcFlag 円弧の大きい側を使うフラグ\n * @param sweepFlag 時計回り円弧を使うフラグ\n * @param radian 傾き\n * @param size 分割数\n * @return 座標リスト\n */\nexport function approximateArcWithPoint(\n  rx: number,\n  ry: number,\n  startPoint: IVec2,\n  endPoint: IVec2,\n  largeArcFlag: boolean,\n  sweepFlag: boolean,\n  radian: number,\n  size: number\n): IVec2[] {\n  if (Math.abs(rx * ry) < MINVALUE) {\n    return [startPoint, endPoint]\n  }\n  return getApproPoints(\n    getArcLerpFn(rx, ry, startPoint, endPoint, largeArcFlag, sweepFlag, radian),\n    size\n  )\n}\n\nexport function getArcLerpFn(\n  rx: number,\n  ry: number,\n  startPoint: IVec2,\n  endPoint: IVec2,\n  largeArcFlag: boolean,\n  sweepFlag: boolean,\n  radian: number\n): (t: number) => IVec2 {\n  if (Math.abs(rx * ry) < MINVALUE) {\n    return (t) => lerpPoint(p0, p1, t)\n  }\n\n  const r = radian\n  const rotateFn = getRotateFn(r)\n  const p0 = startPoint\n  const p1 = endPoint\n  const a = rotateFn(vec((p0.x - p1.x) / 2, (p0.y - p1.y) / 2), true)\n  const ax2 = a.x * a.x\n  const ay2 = a.y * a.y\n\n  const l = ax2 / rx / rx + ay2 / ry / ry\n  const lsqrt = l > 1 ? Math.sqrt(l) : 1\n  const { x: rxa, y: rya } = vec(Math.abs(rx) * lsqrt, Math.abs(ry) * lsqrt)\n\n  const rx2 = rxa * rxa\n  const ry2 = rya * rya\n  const b = multi(\n    multi(\n      vec((rxa * a.y) / rya, (-rya * a.x) / rxa),\n      Math.sqrt(\n        Math.max(0, rx2 * ry2 - rx2 * ay2 - ry2 * ax2) / (rx2 * ay2 + ry2 * ax2)\n      )\n    ),\n    largeArcFlag === sweepFlag ? -1 : 1\n  )\n\n  const c = add(rotateFn(b), multi(add(p0, p1), 0.5))\n\n  const u = vec((a.x - b.x) / rxa, (a.y - b.y) / rya)\n  const v = vec((-a.x - b.x) / rxa, (-a.y - b.y) / rya)\n  const theta = getRadian(u)\n  const dtheta_tmp = (getRadian(v) - getRadian(u)) % (2 * Math.PI)\n  const dtheta =\n    !sweepFlag && 0 < dtheta_tmp\n      ? dtheta_tmp - 2 * Math.PI\n      : sweepFlag && dtheta_tmp < 0\n      ? dtheta_tmp + 2 * Math.PI\n      : dtheta_tmp\n\n  return (t) => {\n    const dr = theta + dtheta * t\n    return add(rotateFn(vec(rxa * Math.cos(dr), rya * Math.sin(dr))), c)\n  }\n}\n\nexport function lerpPoint(a: IVec2, b: IVec2, t: number): IVec2 {\n  return add(a, multi(sub(b, a), t))\n}\n\nexport function getApproPoints(\n  lerpFn: (t: number) => IVec2,\n  split: number\n): IVec2[] {\n  if (split <= 1) {\n    return [lerpFn(0), lerpFn(1)]\n  }\n\n  const points: IVec2[] = []\n  let step = 1 / split\n  for (let i = 0; i <= split; i++) {\n    points.push(lerpFn(step * i))\n  }\n  return points\n}\n\n/**\n * ２点を通る楕円の中心を求める\n * @param a 点a\n * @param b 点b\n * @param rx x軸半径\n * @param ry y軸半径\n * @param radian 傾き\n * @return 解となる２点\n * @return { centers: 解となる２点, radiusRate: 半径補正係数 }\n */\nexport function getEllipseCenter(\n  a: IVec2,\n  b: IVec2,\n  rx: number,\n  ry: number,\n  radian: number\n): { centers: IVec2[]; radiusRate: number } {\n  // 回転を打ち消す\n  a = rotate(a, -radian)\n  b = rotate(b, -radian)\n\n  // 媒介変数を利用して円の中心問題にする\n  const A = vec(a.x / rx, a.y / ry)\n  const B = vec(b.x / rx, b.y / ry)\n\n  // 円の中心取得\n  const centerInfo = getCircleCenter(A, B, 1)\n  const C = centerInfo.centers\n\n  // 楕円に戻す\n  let ans1 = vec(C[0].x * rx, C[0].y * ry)\n  let ans2 = vec(C[1].x * rx, C[1].y * ry)\n\n  // 回転を戻す\n  ans1 = rotate(ans1, radian)\n  ans2 = rotate(ans2, radian)\n\n  return {\n    centers: [ans1, ans2],\n    radiusRate: centerInfo.radiusRate,\n  }\n}\n\n/**\n * ２点を通る円の中心を求める\n * @param a 点a\n * @param b 点b\n * @param radius 半径\n * @return { centers: 解となる２点, radiusRate: 半径補正係数 }\n */\nexport function getCircleCenter(\n  a: IVec2,\n  b: IVec2,\n  radius: number\n): { centers: IVec2[]; radiusRate: number } {\n  const u1 = (a.x + b.x) / 2\n  const u2 = (a.x - b.x) / 2\n  const v1 = (a.y + b.y) / 2\n  const v2 = (a.y - b.y) / 2\n  const L = Math.sqrt(u2 * u2 + v2 * v2)\n  const t2 = Math.pow(radius / L, 2) - 1\n\n  // 2点が直径以上に離れている => 2点を直径とみなす\n  if (t2 < 0) {\n    const center = getCenter(a, b)\n    return {\n      centers: [center, center],\n      radiusRate: L / radius,\n    }\n  }\n\n  const t = Math.sqrt(t2)\n  const ans1 = vec(u1 + v2 * t, v1 - u2 * t)\n  const ans2 = vec(u1 - v2 * t, v1 + u2 * t)\n\n  return {\n    centers: [ans1, ans2],\n    radiusRate: 1,\n  }\n}\n\n/**\n * 2次元アフィン変換を行う\n * paramsには以下の行列をa b c d e fの順で指定する\n * a c e\n * b d f\n * @param points 変換前の座標リスト\n * @param params 行列成分\n * @return 座標リスト\n */\nexport function transform(points: IVec2[], params: number[]): IVec2[] {\n  const a = params[0]\n  const b = params[1]\n  const c = params[2]\n  const d = params[3]\n  const e = params[4]\n  const f = params[5]\n\n  return points.map((p) => vec(a * p.x + c * p.y + e, b * p.x + d * p.y + f))\n}\n\n/**\n * invert affine transfomation matrix\n * a c e\n * b d f\n * @param params [a, b, c, d, e, f]\n * @return inverted matrix params\n */\nexport function invertTransform(params: AffineMatrix): AffineMatrix {\n  const [a, b, c, d, e, f] = params\n  const t = a * d - b * c\n  return [\n    d / t,\n    -b / t,\n    -c / t,\n    a / t,\n    (c * f - d * e) / t,\n    -(a * f - b * e) / t,\n  ]\n}\n\n/**\n * multi affine transfomation matrixes\n * @param a affine matrix\n * @param b affine matrix\n * @return a * b\n */\nexport function multiAffine(a: AffineMatrix, b: AffineMatrix): AffineMatrix {\n  return [\n    a[0] * b[0] + a[2] * b[1],\n    a[1] * b[0] + a[3] * b[1],\n    a[0] * b[2] + a[2] * b[3],\n    a[1] * b[2] + a[3] * b[3],\n    a[0] * b[4] + a[2] * b[5] + a[4],\n    a[1] * b[4] + a[3] * b[5] + a[5],\n  ]\n}\n\n/**\n * multi affines\n * @param affines affine matrix list\n * @return affines[0] * affines[1] * ...\n */\nexport function multiAffines(affines: AffineMatrix[]): AffineMatrix {\n  return affines.reduce((p, c) => {\n    return multiAffine(p, c)\n  }, IDENTITY_AFFINE)\n}\n\n/**\n * apply affine\n * @param affine affine matrix\n * @param v vector2\n * @return affine x v\n */\nexport function applyAffine(affine: AffineMatrix, v: IVec2): IVec2 {\n  return vec(\n    affine[0] * v.x + affine[2] * v.y + affine[4],\n    affine[1] * v.x + affine[3] * v.y + affine[5]\n  )\n}\n\n/**\n * 隣り合う同一点をオミットする\n * @method omitSamePoint\n * @param polygon ポリゴン\n * @return オミット後のポリゴン\n */\nexport function omitSamePoint(polygon: IVec2[]): IVec2[] {\n  let ret = polygon.concat()\n\n  // サイズ\n  const size = polygon.length\n  // 同一点探す\n  for (let i = 0; i < size; i++) {\n    const p1 = ret[i]\n    const p2 = ret[(i + 1) % size]\n    if (isSame(p1, p2)) {\n      // 同一\n      ret.splice(i, 1)\n      // 再帰\n      ret = omitSamePoint(ret)\n      break\n    }\n  }\n\n  return ret\n}\n\n/**\n * 正多角形の面積を内接円の半径から求める\n * @param radius 半径\n * @param n 角数\n * @return 面積\n */\nexport function getRegularPolygonArea(radius: number, n: number): number {\n  const unitRad = Math.PI / n\n  const unitArea = Math.pow(radius, 2) * Math.sin(unitRad) * Math.cos(unitRad)\n  return unitArea * n\n}\n\n/**\n * 正多角形の面積から内接円の半径を求める\n * @param area 面積\n * @param n 角数\n * @return 半径\n */\nexport function getRegularPolygonRadius(area: number, n: number): number {\n  const unitRad = Math.PI / n\n  const unitArea = area / n\n  return Math.sqrt(unitArea / Math.sin(unitRad) / Math.cos(unitRad))\n}\n\n/**\n * 包含関係にあるポリゴンをグループ化する\n * @param polygons ポリゴン一覧\n * @return グループ化したポリゴン一覧、グループ内は面積降順\n */\nexport function getIncludedPolygonGroups(polygons: IVec2[][]): IVec2[][][] {\n  const sorted = polygons.concat()\n  sorted.sort((a, b) => {\n    return getArea(b) - getArea(a)\n  })\n  const hit: { [s: string]: boolean } = {}\n  const ret: IVec2[][][] = []\n  sorted.forEach((p, i) => {\n    if (hit[i]) return\n    hit[i] = true\n    const group = [p].concat(\n      sorted.filter((c, j) => {\n        if (hit[j]) return false\n        const pointsOnPolygon = c.filter((point) => isOnPolygon(point, p))\n        if (pointsOnPolygon.length !== c.length) return false\n        hit[j] = true\n        return true\n      })\n    )\n    ret.push(group)\n  })\n  return ret\n}\n\n/**\n * ポリゴンブーリアン演算差\n * 突き抜けは非対応\n * targetは1辺のみでpolyと交差する前提\n * targetとpolyは観点方向が逆である前提\n * @param target ポリゴン\n * @param poly 切り取り範囲ポリゴン\n * @return 切り取った後のポリゴン\n */\nexport function getPolygonNotPolygon(target: IVec2[], poly: IVec2[]): IVec2[] {\n  const ret: IVec2[] = []\n\n  // targetの辺と交差するpolyの辺インデックスを探索\n  let targetCrossIndex: number = -1\n  const polyCrossIndexList: number[] = []\n  const cross: IVec2[] = []\n  for (let i = 0; i < target.length; i++) {\n    const currentSeg = [target[i], target[(i + 1) % target.length]]\n    for (let j = 0; j < poly.length; j++) {\n      const seg = [poly[j], poly[(j + 1) % poly.length]]\n      if (isCrossSegAndSeg(currentSeg, seg)) {\n        const p = getCrossSegAndLine(currentSeg, seg)\n        if (p) {\n          targetCrossIndex = i\n          polyCrossIndexList.push(j)\n          cross.push(p)\n        }\n      }\n    }\n    if (targetCrossIndex !== -1) break\n  }\n\n  if (targetCrossIndex === -1) return target\n  if (polyCrossIndexList.length % 2 !== 0) return target\n\n  // target辺の始点に最も近い交点を探す\n  const distList = cross.map((p) => getDistance(p, target[targetCrossIndex]))\n  const sortedDistList = distList.concat().sort((a, b) => a - b)\n  const nearestCrossIndex = distList.indexOf(sortedDistList[0])\n  const nearestIndex = polyCrossIndexList[nearestCrossIndex]\n\n  // nearestIndexが始点となるようpolyを調整\n  const adjustedPoly: IVec2[] = poly.concat()\n  for (let j = 0; j < nearestIndex; j++) {\n    adjustedPoly.push(adjustedPoly.shift() as IVec2)\n  }\n  // nearestIndexが先頭になるよう調整\n  const adjustedPolyCrossIndexList: number[] = polyCrossIndexList.map((n) => {\n    return (n - nearestIndex + poly.length) % poly.length\n  })\n  const adjustedCross: IVec2[] = cross.concat()\n  for (let k = 0; k < nearestCrossIndex; k++) {\n    adjustedPolyCrossIndexList.push(\n      adjustedPolyCrossIndexList.shift() as number\n    )\n    adjustedCross.push(adjustedCross.shift() as IVec2)\n  }\n\n  // polyと交差する辺が始点と終点になるよう調整\n  for (let i = 0; i < target.length; i++) {\n    ret.push(target[(i + targetCrossIndex + 1) % target.length])\n  }\n\n  // 交点からpolyに突入\n  for (let i = 0; i < adjustedPolyCrossIndexList.length / 2; i++) {\n    const startIndex = adjustedPolyCrossIndexList[i * 2]\n    const endIndex = adjustedPolyCrossIndexList[i * 2 + 1]\n    ret.push(adjustedCross[i * 2])\n    for (let j = startIndex + 1; j <= endIndex; j++) {\n      ret.push(adjustedPoly[j])\n    }\n    ret.push(adjustedCross[i * 2 + 1])\n  }\n\n  return ret\n}\n\n/**\n * ポリゴン全てを包含する矩形を取得\n * @param polygons ポリゴン一覧\n * @return 外接矩形\n */\nexport function getOuterRectangle(polygons: IVec2[][]): IRectangle {\n  if (polygons.length === 0)\n    return {\n      x: 0,\n      y: 0,\n      width: 0,\n      height: 0,\n    }\n\n  let minX = Infinity\n  let minY = Infinity\n  let maxX = -Infinity\n  let maxY = -Infinity\n\n  for (let i = 0; i < polygons.length; i++) {\n    const polygon = polygons[i]\n    for (let j = 0; j < polygon.length; j++) {\n      const v = polygon[j]\n      minX = Math.min(minX, v.x)\n      minY = Math.min(minY, v.y)\n      maxX = Math.max(maxX, v.x)\n      maxY = Math.max(maxY, v.y)\n    }\n  }\n\n  return {\n    x: minX,\n    y: minY,\n    width: maxX - minX,\n    height: maxY - minY,\n  }\n}\n\n/**\n * 矩形範囲のグリッド取得\n * @param range 矩形範囲\n * @param gridSize グリッド幅\n * @param dX x軸のずらし幅\n * @param dY y軸のずらし幅\n * @return グリッド線リスト\n */\nexport function getGrid(\n  range: IRectangle,\n  gridSize: number,\n  dX: number = 0,\n  dY: number = 0\n): IVec2[][] {\n  const gridList: IVec2[][] = []\n  const minX = range.x\n  const maxX = range.x + range.width\n  const minY = range.y\n  const maxY = range.y + range.height\n\n  let x = minX + dX\n  while (x < maxX) {\n    if (minX < x && x < maxX) {\n      gridList.push([vec(x, minY), vec(x, maxY)])\n    }\n    x += gridSize\n  }\n\n  let y = minY + dY\n  while (y < maxY) {\n    if (minY < y && y < maxY) {\n      gridList.push([vec(minX, y), vec(maxX, y)])\n    }\n    y += gridSize\n  }\n\n  return gridList\n}\n\n/**\n * 矩形を中心基準でサイズ変更する\n * @param org 元の矩形\n * @param dW 幅変更差分\n * @param dH 高さ変更差分\n * @return サイズ変更後の矩形\n */\nexport function expandRecntagle(\n  org: IRectangle,\n  dW: number,\n  dH: number\n): IRectangle {\n  return {\n    x: org.x - dW / 2,\n    y: org.y - dH / 2,\n    width: org.width + dW,\n    height: org.height + dH,\n  }\n}\n\n/**\n * 矩形を中心基準の倍率でサイズ変更する\n * @param org 元の矩形\n * @param scaleW 幅変更倍率\n * @param scaleH 高さ軸変更倍率\n * @return サイズ変更後の矩形\n */\nexport function expandRecntagleScale(\n  org: IRectangle,\n  scaleW: number,\n  scaleH: number\n): IRectangle {\n  return expandRecntagle(\n    org,\n    org.width * (scaleW - 1),\n    org.height * (scaleH - 1)\n  )\n}\n\n/**\n * interpolate scaler\n * @param from\n * @param to\n * @param rate 0 => from, 1 => to\n * @return interpolated value\n */\nexport function interpolateScaler(\n  from: number,\n  to: number,\n  rate: number\n): number {\n  return from * (1 - rate) + to * rate\n}\n\n/**\n * interpolate scaler\n * @param from\n * @param to\n * @param rate 0 => from, 1 => to\n * @return interpolated value\n */\nexport function interpolateVector(from: IVec2, to: IVec2, rate: number): IVec2 {\n  return vec(\n    interpolateScaler(from.x, to.x, rate),\n    interpolateScaler(from.y, to.y, rate)\n  )\n}\n\n/**\n * solve cubic equation for bezier3\n * throw if the equation does not have real solution in 0 <= t <= 1\n * @param a t^3 param\n * @param b t^2 param\n * @param c t param\n * @param d constant param\n * @return unique solution\n */\nfunction solveBezier3Fomula(\n  a: number,\n  b: number,\n  c: number,\n  d: number\n): number {\n  const list = solveQubicFomula(a, b, c, d)\n  if (list.length === 0) return 0\n\n  const ret = getCloseInRangeValue(list, 0, 1)\n  if (ret === undefined)\n    throw new Error('Error: Cannot resolve uniquely in 0 <= t <= 1.')\n\n  return Math.max(Math.min(ret, 1), 0)\n}\n\n/**\n * solve cubic equation in real space\n * @param a t^3 param\n * @param b t^2 param\n * @param c t param\n * @param d constant param\n * @return solutions in no particular order\n */\nexport function solveQubicFomula(\n  a: number,\n  b: number,\n  c: number,\n  d: number\n): number[] {\n  if (isCloseToZero(a)) {\n    return solveEquationOrder2(b, c, d)\n  }\n\n  const p = (3 * a * c - b * b) / (3 * a * a)\n  const q = (2 * b * b * b - 9 * a * b * c + 27 * a * a * d) / (27 * a * a * a)\n\n  const Z = -b / (3 * a)\n\n  if (isCloseToZero(p) && isCloseToZero(q)) {\n    // triple real root\n    return [Z]\n  }\n\n  const D = (27 * q * q + 4 * p * p * p) / 108\n  if (isCloseToZero(D)) {\n    // one distinct root and double real root\n    const Q = Math.sign(q) * Math.pow(Math.abs(q) / 2, 1 / 3)\n    return [-2 * Q + Z, Q + Z]\n  } else if (D > 0) {\n    const sqrtD = Math.sqrt(D)\n    const tmpA = -q / 2 + sqrtD\n    const tmpB = -q / 2 - sqrtD\n    const A = Math.sign(tmpA) * Math.pow(Math.abs(tmpA), 1 / 3)\n    const B = Math.sign(tmpB) * Math.pow(Math.abs(tmpB), 1 / 3)\n\n    return [A + B + Z]\n  } else {\n    // three distinct real roots\n    const A = -q / 2\n    const B = Math.sqrt(-D)\n    const r = Math.atan2(B, A)\n    const C = 2 * Math.pow(A * A + B * B, 1 / 6)\n    const D0 = Math.cos(r / 3)\n    const D1 = Math.cos((r + 2 * Math.PI) / 3)\n    const D2 = Math.cos((r + 4 * Math.PI) / 3)\n\n    const T0 = C * D0 + Z\n    const T1 = C * D1 + Z\n    const T2 = C * D2 + Z\n\n    return [T0, T1, T2]\n  }\n}\n\nfunction getCloseInRangeValue(\n  values: number[],\n  min: number,\n  max: number\n): number | undefined {\n  return values.find((val) => {\n    if (min <= val && val <= max) return true\n    if (isCloseTo(val, min) || isCloseTo(val, max)) return true\n    return false\n  })\n}\n\nfunction isCloseTo(val: number, target: number): boolean {\n  return Math.abs(val - target) < MINVALUE\n}\n\nfunction isCloseToZero(val: number): boolean {\n  return Math.abs(val) < MINVALUE\n}\n\n/**\n * clamp number\n * @param min min value\n * @param max max value\n * @return clamped value\n */\nexport function clamp(min = -Infinity, max = Infinity, val: number) {\n  return Math.max(Math.min(val, max), min)\n}\n\n/**\n * clamp number circularly\n * @param min min value\n * @param max max value\n * @return clamped value\n */\nexport function circleClamp(min: number, max: number, val: number) {\n  if (min === max) return min\n\n  if (max < val) {\n    return ((val - max) % (max - min)) + min\n  } else if (val < min) {\n    return max - ((min - val) % (max - min))\n  } else {\n    return val\n  }\n}\n\n/**\n * round trip value\n * @param min min value\n * @param max max value\n * @return round tripped value\n */\nexport function roundTrip(min: number, max: number, val: number) {\n  const harf = max - min\n  const length = 2 * harf\n  if (length === 0) return min\n\n  const d = Math.abs(val - min) % length\n  if (d < harf) {\n    return d + min\n  } else {\n    return length - d + min\n  }\n}\n","import { AffineMatrix, ISvgConfigs, ISvgPath, ISvgStyle, IVec2 } from './types'\nimport * as geo from './geo'\n\nconst HTTP_SVG = 'http://www.w3.org/2000/svg'\nconst _parseFloat = parseFloat\n\nexport const configs: ISvgConfigs = {\n  bezierSplitSize: 10,\n  ellipseSplitSize: 20,\n}\n\n/**\n * 描画\n * @param ctx 描画要素\n * @param pathInfo 図形情報\n */\nexport function draw(ctx: CanvasRenderingContext2D, pathInfo: ISvgPath): void {\n  ctx.lineCap = pathInfo.style.lineCap as CanvasLineCap\n  ctx.lineJoin = pathInfo.style.lineJoin as CanvasLineJoin\n\n  ctx.beginPath()\n  pathInfo.d.forEach((p, i) => {\n    if (i === 0) {\n      ctx.moveTo(p.x, p.y)\n    } else {\n      ctx.lineTo(p.x, p.y)\n    }\n  })\n  ctx.closePath()\n\n  if (pathInfo.included) {\n    pathInfo.included.forEach((poly) => {\n      poly.forEach((p, i) => {\n        if (i === 0) {\n          ctx.moveTo(p.x, p.y)\n        } else {\n          ctx.lineTo(p.x, p.y)\n        }\n      })\n      ctx.closePath()\n    })\n  }\n\n  if (pathInfo.style.fill) {\n    ctx.fillStyle = pathInfo.style.fillStyle\n    ctx.globalAlpha = pathInfo.style.fillGlobalAlpha\n    ctx.fill()\n  }\n\n  // 枠\n  if (pathInfo.style.stroke) {\n    ctx.strokeStyle = pathInfo.style.strokeStyle\n    ctx.globalAlpha = pathInfo.style.strokeGlobalAlpha\n    ctx.lineWidth = pathInfo.style.lineWidth\n    ctx.setLineDash(pathInfo.style.lineDash)\n    ctx.stroke()\n  }\n  ctx.globalAlpha = 1\n}\n\n/**\n * 矩形に収まるよう調整\n * @param pathInfoList パス情報リスト\n * @param x 矩形x座標\n * @param y 矩形y座標\n * @param width 矩形width\n * @param height 矩形height\n * @return 調整後パス情報リスト\n */\nexport function fitRect(\n  pathInfoList: ISvgPath[],\n  x: number,\n  y: number,\n  width: number,\n  height: number\n): ISvgPath[] {\n  let minX: number = Infinity\n  let maxX: number = -Infinity\n  let minY: number = Infinity\n  let maxY: number = -Infinity\n  pathInfoList.forEach((info) => {\n    info.d.forEach((p) => {\n      minX = Math.min(minX, p.x)\n      maxX = Math.max(maxX, p.x)\n      minY = Math.min(minY, p.y)\n      maxY = Math.max(maxY, p.y)\n    })\n  })\n\n  // 原点基準に移動\n  const fromBaseList = pathInfoList.map((info) => ({\n    ...info,\n    d: info.d.map((p) => geo.vec(p.x - minX, p.y - minY)),\n  }))\n  // 伸縮\n  const orgWidth = maxX - minX\n  const orgHeight = maxY - minY\n  const rateX = width / orgWidth\n  const rateY = height / orgHeight\n  const rate = Math.min(rateX, rateY)\n  const scaledList = fromBaseList.map((info) => ({\n    ...info,\n    d: info.d.map((p) => geo.vec(p.x * rate, p.y * rate)),\n  }))\n  // 矩形位置に移動\n  const difX = x + (width - orgWidth * rate) / 2\n  const difY = y + (height - orgHeight * rate) / 2\n  const convertedList: ISvgPath[] = scaledList.map((info) => ({\n    ...info,\n    d: info.d.map((p) => geo.vec(p.x + difX, p.y + difY)),\n    included: (info.included || []).map((poly: IVec2[]) => {\n      return poly.map((p) =>\n        geo.vec((p.x - minX) * rate + difX, (p.y - minY) * rate + difY)\n      )\n    }),\n  }))\n\n  return convertedList\n}\n\n/**\n * SVG文字列から図形のパス情報を取得する\n * 対応タグ: path,rect,ellipse,circle\n * @param svgString SVGリソース文字列\n * @return パス情報リスト\n */\nexport function parseSvgGraphicsStr(svgString: string): ISvgPath[] {\n  const domParser = new DOMParser()\n  const svgDom = domParser.parseFromString(svgString, 'image/svg+xml')\n  const svgTags = svgDom.getElementsByTagName('svg')\n  if (!svgTags || svgTags.length === 0) return []\n  return parseSvgGraphics(svgTags[0] as SVGElement)\n}\n\n/**\n * parse SVG tree\n * @param elm SVGElement\n * @return path informations\n */\nfunction parseSvgTree(\n  elm: SVGElement,\n  parentInfo?: { style?: ISvgStyle; transform?: AffineMatrix }\n): ISvgPath[] {\n  const style = { ...(parentInfo?.style ?? {}), ...parseTagStyle(elm) }\n\n  const transformStr = elm.getAttribute('transform')\n  const parentTransform = parentInfo?.transform ?? geo.IDENTITY_AFFINE\n\n  let ret: ISvgPath[] = []\n\n  const svgPath = parseSVGShape(elm)\n  if (svgPath) {\n    ret.push({\n      ...svgPath,\n      d: svgPath.d.map((v) => geo.applyAffine(parentTransform, v)),\n    })\n  }\n\n  if (elm.children.length > 0) {\n    const transform = transformStr\n      ? geo.multiAffine(parentTransform, parseTransform(transformStr))\n      : parentTransform\n\n    Array.from(elm.children).forEach((child) => {\n      ret = ret.concat(parseSvgTree(child as SVGElement, { style, transform }))\n    })\n  }\n\n  return ret\n}\n\nfunction parseSVGShape(elm: SVGElement): ISvgPath | undefined {\n  switch (elm.tagName.toLowerCase()) {\n    case 'path':\n      return {\n        d: parsePath(elm as SVGPathElement),\n        style: parseTagStyle(elm),\n      }\n    case 'rect':\n      return {\n        d: parseRect(elm as SVGRectElement),\n        style: parseTagStyle(elm),\n      }\n    case 'ellipse':\n      return {\n        d: parseEllipse(elm as SVGEllipseElement),\n        style: parseTagStyle(elm),\n      }\n    case 'circle':\n      return {\n        d: parseCircle(elm as SVGCircleElement),\n        style: parseTagStyle(elm),\n      }\n    default:\n      return undefined\n  }\n}\n\n/**\n * SVGタグから図形のパス情報を取得する\n * 対応タグ: path,rect,ellipse,circle\n * @param svgTag SVGタグ\n * @return パス情報リスト\n */\nexport function parseSvgGraphics(svgTag: SVGElement): ISvgPath[] {\n  return parseSvgTree(svgTag)\n}\n\n/**\n * opentype.jsのpath.commandをd文字列に変換する\n * @param fontPath opentype.jsのpath.command\n * @return d文字列\n */\nexport function openCommandToD(command: any): string {\n  let d: string = command.type\n  if ('x1' in command) d += ` ${command.x1}`\n  if ('y1' in command) d += ` ${command.y1}`\n  if ('x2' in command) d += ` ${command.x2}`\n  if ('y2' in command) d += ` ${command.y2}`\n  if ('x3' in command) d += ` ${command.x3}`\n  if ('y3' in command) d += ` ${command.y3}`\n  if ('x' in command) d += ` ${command.x}`\n  if ('y' in command) d += ` ${command.y}`\n  return d\n}\n\n/**\n * opentype.jsのpathを解析する\n * @param fontPath opentype.jsのpath\n * @return パス情報リスト\n */\nexport function parseOpenPath(fontPath: { commands: any[] }): ISvgPath[] {\n  const pathInfoList: ISvgPath[] = []\n  let current: string = ''\n  fontPath.commands.forEach((c: any) => {\n    current += openCommandToD(c) + ' '\n    if (current && c.type.toUpperCase() === 'Z') {\n      const pathList = parsePathD(current)\n      pathInfoList.push({\n        d: pathList,\n        style: {\n          ...createStyle(),\n          fill: true,\n          fillStyle: 'black',\n          stroke: false,\n        },\n      })\n      current = ''\n    }\n  })\n  return pathInfoList\n}\n\ntype PathSegment =\n  | {\n      command: string\n      lerpFn: (t: number) => IVec2\n      curve: true\n    }\n  | {\n      command: string\n      segment: [IVec2, IVec2]\n      curve?: undefined\n    }\n\nexport function parsePathSegments(dStr: string): PathSegment[] {\n  const ret: PathSegment[] = []\n  let startP = geo.vec(0, 0)\n  let currentP = geo.vec(0, 0)\n  let currentControlP = geo.vec(0, 0)\n  splitD(dStr).forEach((current) => {\n    switch (current[0]) {\n      case 'M': {\n        const p1 = geo.vec(_parseFloat(current[1]), _parseFloat(current[2]))\n        ret.push({ command: 'M', segment: [p1, p1] })\n        startP = p1\n        currentControlP = p1\n        currentP = p1\n        break\n      }\n      case 'm': {\n        const p1 = geo.vec(_parseFloat(current[1]), _parseFloat(current[2]))\n        ret.push({ command: 'm', segment: [p1, p1] })\n        startP = p1\n        currentP = p1\n        currentControlP = p1\n        break\n      }\n      case 'L': {\n        const p0 = currentP\n        const p1 = geo.vec(_parseFloat(current[1]), _parseFloat(current[2]))\n        ret.push({ command: 'L', segment: [p0, p1] })\n        startP ??= p1\n        currentControlP = p1\n        currentP = p1\n        break\n      }\n      case 'l': {\n        const p0 = currentP\n        const p1 = geo.add(\n          currentP,\n          geo.vec(_parseFloat(current[1]), _parseFloat(current[2]))\n        )\n        ret.push({ command: 'l', segment: [p0, p1] })\n        startP ??= p1\n        currentControlP = p1\n        currentP = p1\n        break\n      }\n      case 'H': {\n        const p0 = currentP\n        const p1 = geo.vec(_parseFloat(current[1]), p0.y)\n        ret.push({ command: 'H', segment: [p0, p1] })\n        currentControlP = p1\n        currentP = p1\n        break\n      }\n      case 'h': {\n        const p0 = currentP\n        const p1 = geo.vec(_parseFloat(current[1]) + p0.x, p0.y)\n        ret.push({ command: 'h', segment: [p0, p1] })\n        currentControlP = p1\n        currentP = p1\n        break\n      }\n      case 'V': {\n        const p0 = currentP\n        const p1 = geo.vec(p0.x, _parseFloat(current[1]))\n        ret.push({ command: 'V', segment: [p0, p1] })\n        currentControlP = p1\n        currentP = p1\n        break\n      }\n      case 'v': {\n        const p0 = currentP\n        const p1 = geo.vec(p0.x, _parseFloat(current[1]) + p0.y)\n        ret.push({ command: 'v', segment: [p0, p1] })\n        currentControlP = p1\n        currentP = p1\n        break\n      }\n      case 'Q': {\n        const p0 = currentP\n        const p1 = geo.vec(_parseFloat(current[1]), _parseFloat(current[2]))\n        const p2 = geo.vec(_parseFloat(current[3]), _parseFloat(current[4]))\n        ret.push({\n          command: 'Q',\n          lerpFn: geo.getBezier2LerpFn([p0, p1, p2]),\n          curve: true,\n        })\n        currentControlP = p1\n        currentP = p2\n        break\n      }\n      case 'q': {\n        const p0 = currentP\n        const p1 = geo.add(\n          p0,\n          geo.vec(_parseFloat(current[1]), _parseFloat(current[2]))\n        )\n        const p2 = geo.add(\n          p0,\n          geo.vec(_parseFloat(current[3]), _parseFloat(current[4]))\n        )\n        ret.push({\n          command: 'q',\n          lerpFn: geo.getBezier2LerpFn([p0, p1, p2]),\n          curve: true,\n        })\n        currentControlP = p1\n        currentP = p2\n        break\n      }\n      case 'T': {\n        const p0 = currentP\n        const p1 = geo.getSymmetry(currentControlP, p0)\n        const p2 = geo.vec(_parseFloat(current[1]), _parseFloat(current[2]))\n        ret.push({\n          command: 'T',\n          lerpFn: geo.getBezier2LerpFn([p0, p1, p2]),\n          curve: true,\n        })\n        currentControlP = p1\n        currentP = p2\n        break\n      }\n      case 't': {\n        const p0 = currentP\n        const p1 = geo.getSymmetry(currentControlP, p0)\n        const p2 = geo.add(\n          p0,\n          geo.vec(_parseFloat(current[1]), _parseFloat(current[2]))\n        )\n        ret.push({\n          command: 't',\n          lerpFn: geo.getBezier2LerpFn([p0, p1, p2]),\n          curve: true,\n        })\n        currentControlP = p1\n        currentP = p2\n        break\n      }\n      case 'C': {\n        const p0 = currentP\n        const p1 = geo.vec(_parseFloat(current[1]), _parseFloat(current[2]))\n        const p2 = geo.vec(_parseFloat(current[3]), _parseFloat(current[4]))\n        const p3 = geo.vec(_parseFloat(current[5]), _parseFloat(current[6]))\n        ret.push({\n          command: 'C',\n          lerpFn: geo.getBezier3LerpFn([p0, p1, p2, p3]),\n          curve: true,\n        })\n        currentControlP = p2\n        currentP = p3\n        break\n      }\n      case 'c': {\n        const p0 = currentP\n        const p1 = geo.add(\n          p0,\n          geo.vec(_parseFloat(current[1]), _parseFloat(current[2]))\n        )\n        const p2 = geo.add(\n          p0,\n          geo.vec(_parseFloat(current[3]), _parseFloat(current[4]))\n        )\n        const p3 = geo.add(\n          p0,\n          geo.vec(_parseFloat(current[5]), _parseFloat(current[6]))\n        )\n        ret.push({\n          command: 'c',\n          lerpFn: geo.getBezier3LerpFn([p0, p1, p2, p3]),\n          curve: true,\n        })\n        currentControlP = p2\n        currentP = p3\n        break\n      }\n      case 'S': {\n        const p0 = currentP\n        const p1 = geo.getSymmetry(currentControlP, p0)\n        const p2 = geo.vec(_parseFloat(current[1]), _parseFloat(current[2]))\n        const p3 = geo.vec(_parseFloat(current[3]), _parseFloat(current[4]))\n        ret.push({\n          command: 'S',\n          lerpFn: geo.getBezier3LerpFn([p0, p1, p2, p3]),\n          curve: true,\n        })\n        currentControlP = p2\n        currentP = p3\n        break\n      }\n      case 's': {\n        const p0 = currentP\n        const p1 = geo.getSymmetry(currentControlP, p0)\n        const p2 = geo.add(\n          p0,\n          geo.vec(_parseFloat(current[1]), _parseFloat(current[2]))\n        )\n        const p3 = geo.add(\n          p0,\n          geo.vec(_parseFloat(current[3]), _parseFloat(current[4]))\n        )\n        ret.push({\n          command: 's',\n          lerpFn: geo.getBezier3LerpFn([p0, p1, p2, p3]),\n          curve: true,\n        })\n        currentControlP = p2\n        currentP = p3\n        break\n      }\n      case 'A': {\n        const p0 = currentP\n        const rx = _parseFloat(current[1])\n        const ry = _parseFloat(current[2])\n        const large = current[4] !== '0'\n        const sweep = current[5] !== '0'\n        const radian = (_parseFloat(current[3]) / 180) * Math.PI\n        const p1 = geo.vec(_parseFloat(current[6]), _parseFloat(current[7]))\n        ret.push({\n          command: 'A',\n          lerpFn: geo.getArcLerpFn(rx, ry, p0, p1, large, sweep, radian),\n          curve: true,\n        })\n        currentControlP = p1\n        currentP = p1\n        break\n      }\n      case 'a': {\n        const p0 = currentP\n        const rx = _parseFloat(current[1])\n        const ry = _parseFloat(current[2])\n        const large = current[4] !== '0'\n        const sweep = current[5] !== '0'\n        const radian = (_parseFloat(current[3]) / 180) * Math.PI\n        const p1 = geo.add(\n          p0,\n          geo.vec(_parseFloat(current[6]), _parseFloat(current[7]))\n        )\n        ret.push({\n          command: 'a',\n          lerpFn: geo.getArcLerpFn(rx, ry, p0, p1, large, sweep, radian),\n          curve: true,\n        })\n        currentControlP = p1\n        currentP = p1\n        break\n      }\n      case 'Z':\n      case 'z': {\n        const p0 = currentP\n        const p1 = startP\n        ret.push({\n          command: current[0],\n          segment: [p0, p1],\n        })\n        currentControlP = p1\n        currentP = p1\n        break\n      }\n    }\n  })\n\n  return ret\n}\n\nexport interface PathLengthStruct {\n  lerpFn: (t: number) => IVec2\n  length: number\n}\n\nexport function getPathLengthStructs(\n  dStr: string,\n  split = configs.bezierSplitSize\n): PathLengthStruct[] {\n  return parsePathSegments(dStr).map((seg) => ({\n    lerpFn: seg.curve\n      ? seg.lerpFn\n      : (t) => geo.lerpPoint(seg.segment[0], seg.segment[1], t),\n    length: geo.getPolylineLength(\n      seg.curve ? geo.getApproPoints(seg.lerpFn, split) : seg.segment\n    ),\n  }))\n}\n\n/**\n * Execute \"getPathTotalLength\" with cacheable structs generated by \"getPathLengthStructs\"\n */\nexport function getPathTotalLengthFromStructs(\n  structs: PathLengthStruct[]\n): number {\n  return structs.reduce((p, s) => p + s.length, 0)\n}\n\n/**\n * Alternative function of \"SVGGeometryElement.getTotalLength\"\n * @param dStr d string of path element\n * @param split the number of segments to approximate a curve\n * @return total length of the path\n */\nexport function getPathTotalLength(\n  dStr: string,\n  split = configs.bezierSplitSize\n): number {\n  return getPathTotalLengthFromStructs(getPathLengthStructs(dStr, split))\n}\n\n/**\n * Execute \"getPathPointAtLength\" with cacheable structs generated by \"getPathLengthStructs\"\n */\nexport function getPathPointAtLengthFromStructs(\n  structs: PathLengthStruct[],\n  distance: number\n): IVec2 {\n  let l = Math.max(distance, 0)\n  for (let i = 0; i < structs.length; i++) {\n    const s = structs[i]\n    if (l < s.length) {\n      return s.lerpFn(l / s.length)\n    } else {\n      l -= s.length\n    }\n  }\n  return structs.length > 0\n    ? structs[structs.length - 1].lerpFn(1)\n    : geo.vec(0, 0)\n}\n\n/**\n * Alternative function of \"SVGGeometryElement.getPointAtLength\"\n * @param dStr d string of path element\n * @param distance target length\n * @param split the number of segments to approximate a curve\n * @return the point at the target length\n */\nexport function getPathPointAtLength(\n  dStr: string,\n  distance: number,\n  split = configs.bezierSplitSize\n): IVec2 {\n  return getPathPointAtLengthFromStructs(\n    getPathLengthStructs(dStr, split),\n    distance\n  )\n}\n\n/**\n * Parse path d string and approximate it as a polyline\n * Note:\n * - Jump information by M/m commands doesn't remain in a polyline\n * - Z/z commands are ignored => The tail point doesn't become the same as the head one by these commands\n * @param dStr d string of path element\n * @return approximated polyline\n */\nexport function parsePathD(\n  dStr: string,\n  split = configs.bezierSplitSize\n): IVec2[] {\n  let ret: IVec2[] = []\n  parsePathSegments(dStr).forEach((seg) => {\n    if (seg.command === 'Z' || seg.command === 'z') return\n\n    if (seg.curve) {\n      const list = geo.getApproPoints(seg.lerpFn, split)\n      list.shift()\n      ret = ret.concat(list)\n    } else {\n      ret.push(seg.segment[1])\n    }\n  })\n  return ret\n}\n\n/**\n * pathタグを解析する\n * @param svgPath SVGのpathタグDOM\n * @return 座標リスト\n */\nexport function parsePath(svgPath: SVGPathElement): IVec2[] {\n  const dStr = svgPath.getAttribute('d')\n  return dStr\n    ? adoptTransform(svgPath.getAttribute('transform'), parsePathD(dStr))\n    : []\n}\n\n/**\n * rectタグを解析する\n * @param SVGのrectタグDOM\n * @return 座標リスト\n */\nexport function parseRect(svgRect: SVGRectElement): IVec2[] {\n  const x = _parseFloat(svgRect.getAttribute('x') || '0')\n  const y = _parseFloat(svgRect.getAttribute('y') || '0')\n  const width = _parseFloat(svgRect.getAttribute('width') || '0')\n  const height = _parseFloat(svgRect.getAttribute('height') || '0')\n\n  // トランスフォーム\n  return adoptTransform(svgRect.getAttribute('transform'), [\n    geo.vec(x, y),\n    geo.vec(x + width, y),\n    geo.vec(x + width, y + height),\n    geo.vec(x, y + height),\n  ])\n}\n\n/**\n * ellipseタグを解析する\n * @param svgEllipse SVGのellipseタグDOM\n * @return 座標リスト\n */\nexport function parseEllipse(svgEllipse: SVGEllipseElement): IVec2[] {\n  const cx = _parseFloat(svgEllipse.getAttribute('cx') || '0')\n  const cy = _parseFloat(svgEllipse.getAttribute('cy') || '0')\n  const rx = _parseFloat(svgEllipse.getAttribute('rx') || '1')\n  const ry = _parseFloat(svgEllipse.getAttribute('ry') || '1')\n\n  // トランスフォーム\n  return adoptTransform(\n    svgEllipse.getAttribute('transform'),\n    geo.approximateArc(\n      rx,\n      ry,\n      0,\n      Math.PI * 2,\n      geo.vec(cx, cy),\n      0,\n      configs.ellipseSplitSize\n    )\n  )\n}\n\n/**\n * circleタグを解析する\n * @param svgCircle  SVGのcircleタグDOM\n * @return 座標リスト\n */\nexport function parseCircle(svgCircle: SVGCircleElement): IVec2[] {\n  const cx = _parseFloat(svgCircle.getAttribute('cx') || '0')\n  const cy = _parseFloat(svgCircle.getAttribute('cy') || '0')\n  const r = _parseFloat(svgCircle.getAttribute('r') || '1')\n\n  // トランスフォーム\n  return adoptTransform(\n    svgCircle.getAttribute('transform'),\n    geo.approximateArc(\n      r,\n      r,\n      0,\n      Math.PI * 2,\n      geo.vec(cx, cy),\n      0,\n      configs.ellipseSplitSize\n    )\n  )\n}\n\n/**\n * transformを行う\n * @param commandStr コマンド文字列\n * @param points 変換前座標リスト\n * @return 変形後座標リスト\n */\nexport function adoptTransform(\n  commandStr: string | null,\n  points: IVec2[]\n): IVec2[] {\n  if (!commandStr) return points\n\n  let ret: IVec2[] = geo.cloneVectors(points)\n  // 複数コマンドの場合もあるのでループ\n  const commandList = commandStr.split(/\\)/)\n  commandList.forEach((current) => {\n    const tmp = current.split(/\\(/)\n    if (tmp.length === 2) {\n      const command = tmp[0].trim().toLowerCase()\n      const params = parseNumbers(tmp[1])\n\n      switch (command) {\n        case 'matrix': {\n          ret = geo.transform(ret, params)\n          break\n        }\n        case 'translate': {\n          ret = ret.map((p) => geo.vec(p.x + params[0], p.y + params[1]))\n          break\n        }\n        case 'scale': {\n          const scaleX = params[0]\n          // XY等倍の場合を考慮\n          let scaleY = params[0]\n          if (params.length > 1) {\n            scaleY = params[1]\n          }\n          ret = ret.map((p) => geo.vec(p.x * scaleX, p.y * scaleY))\n          break\n        }\n        case 'rotate': {\n          // 回転基準点\n          let base: IVec2 = geo.vec(0, 0)\n          if (params.length > 2) {\n            base = geo.vec(params[1], params[2])\n          }\n          ret = ret.map((p) => geo.rotate(p, (params[0] * Math.PI) / 180, base))\n          break\n        }\n        case 'skewx': {\n          ret = ret.map((p) =>\n            geo.vec(p.x + Math.tan((params[0] * Math.PI) / 180) * p.y, p.y)\n          )\n          break\n        }\n        case 'skewy': {\n          ret = ret.map((p) =>\n            geo.vec(p.x, p.y + Math.tan((params[0] * Math.PI) / 180) * p.x)\n          )\n          break\n        }\n      }\n    }\n  })\n\n  return ret\n}\n\n/**\n * pathタグd属性文字列を分割する\n * @param dString pathのd要素文字列\n * @return コマンド単位の情報配列の配列\n */\nexport function splitD(dString: string): string[][] {\n  // 全コマンドリスト(BbRr非対応)\n  const allCommand = /M|m|L|l|H|h|V|v|C|c|S|s|Q|q|T|t|A|a|Z|z/g\n  // 要素分割\n  const strList = dString\n    .replace(allCommand, ' $& ')\n    .replace(/([^e])(-\\d(\\d*\\.?)\\d*)/g, '$1 $2 ')\n    .split(/,| /)\n    .filter((str) => str)\n  // 直前のコマンド\n  let pastCommand = 'M'\n\n  const ret = []\n  for (let i = 0; i < strList.length; ) {\n    let info = []\n    // コマンドがあるか？\n    if (strList[i].match(allCommand)) {\n      // あるので回収\n      info[0] = strList[i].trim()\n      pastCommand = info[0]\n      // 進む\n      i++\n    } else {\n      // 前回同様\n      info[0] = pastCommand\n    }\n\n    // 情報数で場合分け\n    if (info[0].match(/Z|z/)) {\n      // 0つ\n    } else if (info[0].match(/V|v|H|h/)) {\n      // 1つ\n      info = info.concat(strList.slice(i, i + 1))\n      i += 1\n    } else if (info[0].match(/M|m|L|l|T|t/)) {\n      // 2つ\n      info = info.concat(strList.slice(i, i + 2))\n      i += 2\n    } else if (info[0].match(/Q|q|S|s/)) {\n      // 4つ\n      info = info.concat(strList.slice(i, i + 4))\n      i += 4\n    } else if (info[0].match(/C|c/)) {\n      // 6つ\n      info = info.concat(strList.slice(i, i + 6))\n      i += 6\n    } else if (info[0].match(/A|a/)) {\n      // 7つ\n      info = info.concat(strList.slice(i, i + 7))\n      i += 7\n    } else {\n      // 不適\n      break\n    }\n\n    ret.push(info)\n  }\n\n  return ret\n}\n\n/**\n * svg文字列を生成する\n * @param pathList path情報リスト\n * @return xml文字列\n */\nexport function serializeSvgString(pathList: ISvgPath[]): string {\n  const svg = serializeSvg(pathList)\n  const xmlSerializer = new XMLSerializer()\n  const textXml = xmlSerializer.serializeToString(svg)\n  return textXml\n}\n\n/**\n * svgタグを生成する\n * @param pathList path情報リスト\n * @return svgタグ\n */\nexport function serializeSvg(pathList: ISvgPath[]): SVGElement {\n  const dom = document.createElementNS(HTTP_SVG, 'svg')\n\n  // キャンバスサイズ\n  let width = 1\n  let height = 1\n\n  pathList.forEach((path) => {\n    dom.appendChild(serializePath(path.d, path.style))\n    path.d.forEach((p) => {\n      width = Math.max(width, p.x)\n      height = Math.max(height, p.y)\n    })\n  })\n\n  width *= 1.1\n  height *= 1.1\n\n  dom.setAttribute('width', `${width}`)\n  dom.setAttribute('height', `${height}`)\n\n  return dom\n}\n\n/**\n * pathタグを生成する\n * @param pointList 座標リスト\n * @param style スタイル情報\n * @return pathタグ\n */\nexport function serializePath(\n  pointList: IVec2[],\n  style: ISvgStyle\n): SVGPathElement {\n  const dom = document.createElementNS(HTTP_SVG, 'path')\n  dom.setAttribute('d', serializePointList(pointList))\n  dom.setAttribute('style', serializeStyle(style))\n  return dom\n}\n\n/**\n * 座標リストをd属性文字列に変換する\n * @param pointList 座標リスト\n * @param open 閉じないフラグ\n * @return d属性文字列\n */\nexport function serializePointList(pointList: IVec2[], open?: boolean): string {\n  if (pointList.length === 0) return ''\n  const [head, ...body] = pointList\n  return (\n    `M ${head.x},${head.y}` +\n    body.map((p) => ` L ${p.x},${p.y}`).join('') +\n    (open ? '' : ' Z')\n  )\n}\n\n/**\n * デフォルトstyle作成\n * @return スタイルオブジェクト\n */\nexport function createStyle() {\n  return {\n    fill: false,\n    fillGlobalAlpha: 1,\n    fillStyle: '',\n    lineCap: 'butt',\n    lineDash: [],\n    lineJoin: 'bevel',\n    lineWidth: 1,\n    stroke: false,\n    strokeGlobalAlpha: 1,\n    strokeStyle: '',\n  }\n}\n\n/**\n * pathタグのスタイルを取得する\n * @param svgPath SVGのpathタグDOM\n * @return スタイルオブジェクト\n */\nexport function parseTagStyle(svgPath: SVGElement): ISvgStyle {\n  // スタイル候補要素リスト\n  const styleObject: { [key: string]: string } = {}\n\n  svgPath.getAttributeNames().forEach((name) => {\n    const attr = svgPath.getAttributeNode(name)\n    if (!attr) return\n    styleObject[attr.name] = attr.value\n  })\n\n  const styleAttr = svgPath.getAttributeNode('style')\n  if (styleAttr) {\n    // style要素から取得\n    const styleStr = styleAttr.value\n    styleStr.split(';').forEach((elem: string) => {\n      const splited = elem.split(':')\n      if (splited.length !== 2) return\n      styleObject[splited[0].trim()] = splited[1].trim()\n    })\n  }\n\n  return Object.entries(styleObject).reduce<ISvgStyle>((ret, [key, val]) => {\n    switch (key.toLowerCase()) {\n      case 'fill':\n        if (val === 'none') {\n          ret.fillStyle = ''\n          ret.fill = false\n        } else {\n          ret.fillStyle = val\n          ret.fill = true\n        }\n        break\n      case 'stroke':\n        if (val === 'none') {\n          ret.strokeStyle = ''\n          ret.stroke = false\n        } else {\n          ret.strokeStyle = val\n          ret.stroke = true\n        }\n        break\n      case 'stroke-width':\n        ret.lineWidth = _parseFloat(val)\n        break\n      case 'stroke-opacity':\n        ret.strokeGlobalAlpha = _parseFloat(val)\n        break\n      case 'fill-opacity':\n        ret.fillGlobalAlpha = _parseFloat(val)\n        break\n      case 'stroke-linecap':\n        ret.lineCap = val\n        break\n      case 'stroke-linejoin':\n        ret.lineJoin = val\n        break\n      case 'stroke-dasharray':\n        if (val.toLowerCase() === 'none') {\n          ret.lineDash = []\n        } else {\n          ret.lineDash = parseNumbers(val)\n        }\n        break\n      default:\n        // 無視\n        break\n    }\n\n    return ret\n  }, createStyle())\n}\n\n/**\n * スタイル情報をstyle属性文字列に変換する\n * @method serializeStyle\n * @param style スタイル情報\n * @return style属性文字列\n */\nexport function serializeStyle(style: ISvgStyle) {\n  let ret = ''\n\n  // fill情報\n  if (!style.fill) {\n    ret += 'fill:none;'\n  } else {\n    ret += 'fill:' + style.fillStyle + ';'\n  }\n  if (style.fillGlobalAlpha) {\n    ret += 'fill-opacity:' + style.fillGlobalAlpha + ';'\n  }\n\n  // stroke情報\n  if (!style.stroke) {\n    ret += 'stroke:none;'\n  } else {\n    ret += 'stroke:' + style.strokeStyle + ';'\n  }\n  if (style.lineWidth) {\n    ret += 'stroke-width:' + style.lineWidth + ';'\n  }\n  if (style.strokeGlobalAlpha) {\n    ret += 'stroke-opacity:' + style.strokeGlobalAlpha + ';'\n  }\n  if (style.lineCap) {\n    ret += 'stroke-linecap:' + style.lineCap + ';'\n  }\n  if (style.lineJoin) {\n    ret += 'stroke-linejoin:' + style.lineJoin + ';'\n  }\n  if (style.lineDash) {\n    if (style.lineDash.length > 0) {\n      ret += 'stroke-dasharray:' + style.lineDash.join(',') + ';'\n    } else {\n      ret += 'stroke-dasharray:none;'\n    }\n  }\n\n  return ret\n}\n\n/**\n * パス分割\n * @param path 対象パス\n * @param line 分割線\n * @return 分割後のパスリスト\n */\nexport function splitPath(path: ISvgPath, line: IVec2[]): ISvgPath[] {\n  let splited = geo.splitPolyByLine(path.d, line)\n  if (splited.length < 2) return [path]\n\n  // 本体と回転方向が一致しているかで分類\n  const rootLoopwise = geo.getLoopwise(path.d)\n  const sameLoopwiseList: IVec2[][] = []\n  const oppositeLoopwiseList: IVec2[][] = []\n  if (path.included) {\n    path.included.forEach((s) => {\n      if (geo.getLoopwise(s) === rootLoopwise) {\n        sameLoopwiseList.push(s)\n      } else {\n        oppositeLoopwiseList.push(s)\n      }\n    })\n  }\n\n  // 本体と同回転のものはそのまま分割\n  sameLoopwiseList.forEach((poly) => {\n    const sp = geo.splitPolyByLine(poly, line)\n    splited = [...splited, ...(sp.length > 0 ? sp : [poly])]\n  })\n\n  // 本体と逆回転のものは特殊処理\n  const notPolyList: IVec2[][] = []\n  oppositeLoopwiseList.forEach((poly) => {\n    const sp = geo.splitPolyByLine(poly, line)\n    if (sp.length > 0) {\n      // 分割されたらブーリアン差をとるために集める\n      notPolyList.push(poly)\n    } else {\n      // 分割なしならそのまま\n      splited.push(poly)\n    }\n  })\n\n  // 切断されたくり抜き領域を差し引いたポリゴンを生成\n  const splitedAfterNot = splited.map((s) =>\n    notPolyList.reduce((p, c) => geo.getPolygonNotPolygon(p, c), s)\n  )\n\n  return geo.getIncludedPolygonGroups(splitedAfterNot).map((group) => {\n    const [d, ...included] = group\n    return { d: d, included, style: path.style }\n  })\n}\n\n/**\n * ポリゴンリストをグルーピングしたパスリストに変換する\n * @param polygons ポリゴンリスト\n * @param style パススタイル\n * @return パスリスト\n */\nexport function getGroupedPathList(\n  polygons: IVec2[][],\n  style: ISvgStyle = createStyle()\n): ISvgPath[] {\n  return geo.getIncludedPolygonGroups(polygons).map((group) => {\n    const [d, ...included] = group\n    return { d, included, style }\n  })\n}\n\n/**\n * convert affine matrix to transform attribute value\n * @param matrix affine matrix\n * @return transform attribute value\n */\nexport function affineToTransform(matrix: AffineMatrix): string {\n  return `matrix(${matrix.join(',')})`\n}\n\n/**\n * parse transform attribute value as affine matrix\n * @param transform attribute value\n * @return transform value\n */\nexport function parseTransform(transformStr: string): AffineMatrix {\n  const transformStrList = transformStr.split(')').map((s) => `${s})`)\n  const affines = transformStrList.map((str) => parseUnitTransform(str))\n  return geo.multiAffines(affines)\n}\n\nfunction parseUnitTransform(str: string): AffineMatrix {\n  if (/translateX/.test(str)) return parseTranslateX(str)\n  if (/translateY/.test(str)) return parseTranslateY(str)\n  if (/translate/.test(str)) return parseTranslate(str)\n  if (/skewX/.test(str)) return parseSkewX(str)\n  if (/skewY/.test(str)) return parseSkewY(str)\n  if (/scaleX/.test(str)) return parseScaleX(str)\n  if (/scaleY/.test(str)) return parseScaleY(str)\n  if (/scale/.test(str)) return parseScale(str)\n  if (/rotate/.test(str)) return parseRotate(str)\n  if (/matrix/.test(str)) return parseMatrix(str)\n  return [...geo.IDENTITY_AFFINE]\n}\n\nfunction parseNumbers(str: string): number[] {\n  const list = str.trim().replace(/,/g, ' ').split(/ +/)\n  return list.map((s) => _parseFloat(s))\n}\n\n/**\n * parse transform attribute value of translate as affine matrix\n * @param transform attribute value\n * @return transform value\n */\nexport function parseTranslate(str: string): AffineMatrix {\n  const splited = str.match(/translate\\((.+)\\)/)\n  if (!splited || splited.length < 1) return [...geo.IDENTITY_AFFINE]\n\n  const numbers = parseNumbers(splited[1])\n  if (numbers.length < 1) {\n    return [...geo.IDENTITY_AFFINE]\n  } else if (numbers.length === 1) {\n    return [1, 0, 0, 1, numbers[0], 0]\n  } else {\n    return [1, 0, 0, 1, numbers[0], numbers[1]]\n  }\n}\n\n/**\n * parse translateX attribute value of translate as affine matrix\n * @param transform attribute value\n * @return transform value\n */\nexport function parseTranslateX(str: string): AffineMatrix {\n  const splited = str.match(/translateX\\((.+)\\)/)\n  if (!splited || splited.length < 1) return [...geo.IDENTITY_AFFINE]\n\n  const numbers = parseNumbers(splited[1])\n  if (numbers.length < 1) {\n    return [...geo.IDENTITY_AFFINE]\n  } else {\n    return [1, 0, 0, 1, numbers[0], 0]\n  }\n}\n\n/**\n * parse translateY attribute value of translate as affine matrix\n * @param transform attribute value\n * @return transform value\n */\nexport function parseTranslateY(str: string): AffineMatrix {\n  const splited = str.match(/translateY\\((.+)\\)/)\n  if (!splited || splited.length < 1) return [...geo.IDENTITY_AFFINE]\n\n  const numbers = parseNumbers(splited[1])\n  if (numbers.length < 1) {\n    return [...geo.IDENTITY_AFFINE]\n  } else {\n    return [1, 0, 0, 1, 0, numbers[0]]\n  }\n}\n\n/**\n * parse skewX attribute value of translate as affine matrix\n * @param transform attribute value\n * @return transform value\n */\nexport function parseSkewX(str: string): AffineMatrix {\n  const splited = str.match(/skewX\\((.+)\\)/)\n  if (!splited || splited.length < 1) return [...geo.IDENTITY_AFFINE]\n\n  const numbers = parseNumbers(splited[1])\n  if (numbers.length < 1) {\n    return [...geo.IDENTITY_AFFINE]\n  } else {\n    return [1, 0, Math.tan((numbers[0] * Math.PI) / 180), 1, 0, 0]\n  }\n}\n\n/**\n * parse skewY attribute value of translate as affine matrix\n * @param transform attribute value\n * @return transform value\n */\nexport function parseSkewY(str: string): AffineMatrix {\n  const splited = str.match(/skewY\\((.+)\\)/)\n  if (!splited || splited.length < 1) return [...geo.IDENTITY_AFFINE]\n\n  const numbers = parseNumbers(splited[1])\n  if (numbers.length < 1) {\n    return [...geo.IDENTITY_AFFINE]\n  } else {\n    return [1, Math.tan((numbers[0] * Math.PI) / 180), 0, 1, 0, 0]\n  }\n}\n\n/**\n * parse transform attribute value of scale as affine matrix\n * @param transform attribute value\n * @return transform value\n */\nexport function parseScale(str: string): AffineMatrix {\n  const splited = str.match(/scale\\((.+)\\)/)\n  if (!splited || splited.length < 2) return [...geo.IDENTITY_AFFINE]\n\n  const numbers = parseNumbers(splited[1])\n  if (numbers.length < 1) {\n    return [...geo.IDENTITY_AFFINE]\n  } else if (numbers.length === 1) {\n    return [numbers[0], 0, 0, numbers[0], 0, 0]\n  } else {\n    return [numbers[0], 0, 0, numbers[1], 0, 0]\n  }\n}\n\n/**\n * parse ScaleX attribute value of translate as affine matrix\n * @param transform attribute value\n * @return transform value\n */\nexport function parseScaleX(str: string): AffineMatrix {\n  const splited = str.match(/scaleX\\((.+)\\)/)\n  if (!splited || splited.length < 1) return [...geo.IDENTITY_AFFINE]\n\n  const numbers = parseNumbers(splited[1])\n  if (numbers.length < 1) {\n    return [...geo.IDENTITY_AFFINE]\n  } else {\n    return [numbers[0], 0, 0, 1, 0, 0]\n  }\n}\n\n/**\n * parse ScaleY attribute value of translate as affine matrix\n * @param transform attribute value\n * @return transform value\n */\nexport function parseScaleY(str: string): AffineMatrix {\n  const splited = str.match(/scaleY\\((.+)\\)/)\n  if (!splited || splited.length < 1) return [...geo.IDENTITY_AFFINE]\n\n  const numbers = parseNumbers(splited[1])\n  if (numbers.length < 1) {\n    return [...geo.IDENTITY_AFFINE]\n  } else {\n    return [1, 0, 0, numbers[0], 0, 0]\n  }\n}\n\n/**\n * parse transform attribute value of rotate as affine matrix\n * @param transform attribute value\n * @return transform value\n */\nexport function parseRotate(str: string): AffineMatrix {\n  const splited = str.match(/rotate\\((.+)\\)/)\n  if (!splited || splited.length < 2) return [...geo.IDENTITY_AFFINE]\n\n  const numbers = parseNumbers(splited[1])\n  if (parseNumbers.length < 1) return [...geo.IDENTITY_AFFINE]\n\n  const rad = (numbers[0] / 180) * Math.PI\n  const cos = Math.cos(rad)\n  const sin = Math.sin(rad)\n  const rot: AffineMatrix = [cos, sin, -sin, cos, 0, 0]\n\n  if (numbers.length > 2) {\n    return geo.multiAffine(\n      geo.multiAffine([1, 0, 0, 1, numbers[1], numbers[2]], rot),\n      [1, 0, 0, 1, -numbers[1], -numbers[2]]\n    )\n  } else {\n    return rot\n  }\n}\n\n/**\n * parse transform attribute value of matrix as affine matrix\n * @param transform attribute value\n * @return transform value\n */\nexport function parseMatrix(str: string): AffineMatrix {\n  const splited = str.match(/matrix\\((.+)\\)/)\n  if (!splited || splited.length < 2) return [...geo.IDENTITY_AFFINE]\n\n  const numbers = parseNumbers(splited[1])\n  if (numbers.length < 5) return [...geo.IDENTITY_AFFINE]\n\n  return numbers.slice(0, 6) as AffineMatrix\n}\n","import * as geo from '../src/geo'\nimport * as svg from '../src/svg'\nimport { ISvgPath } from '../src/types'\n\nconst canvas = document.getElementById('canvas') as HTMLCanvasElement\nconst ctx = canvas.getContext('2d')\nif (ctx) {\n  ctx.clearRect(0, 0, canvas.width, canvas.height)\n\n  const p1 = [\n    { x: 0, y: 0 },\n    { x: 100, y: 0 },\n    { x: 0, y: 100 },\n  ]\n  const p2 = [\n    { x: -100, y: -100 },\n    { x: -100, y: 400 },\n    { x: 200, y: -100 },\n  ]\n  const p3 = [\n    { x: -200, y: -200 },\n    { x: 300, y: -200 },\n    { x: -200, y: 600 },\n  ]\n  const pathInfoList: ISvgPath[] = [\n    {\n      d: [\n        { x: -300, y: 50 },\n        { x: 200, y: 50 },\n        { x: 200, y: 100 },\n        { x: -300, y: 100 },\n      ],\n      style: {\n        ...svg.createStyle(),\n        fill: true,\n        fillStyle: 'red',\n      },\n    },\n    {\n      d: p3,\n      included: [p2, p1],\n      style: {\n        ...svg.createStyle(),\n        fill: true,\n        fillStyle: 'blue',\n      },\n    },\n  ]\n  const inRectList = svg.fitRect(\n    pathInfoList,\n    0,\n    0,\n    canvas.width,\n    canvas.height\n  )\n  inRectList.forEach((info) => svg.draw(ctx, info))\n}\n\nconst fileInput = document.getElementById('input') as HTMLInputElement\nfileInput.onchange = (e) => {\n  const file = (e.target as HTMLInputElement).files\n  if (!file || file.length === 0) return\n\n  const reader = new FileReader()\n  reader.readAsText(file[0])\n  reader.onload = () => {\n    if (!ctx) return\n    ctx.clearRect(0, 0, canvas.width, canvas.height)\n    const pathInfoList = svg.parseSvgGraphicsStr(reader.result as string)\n    const inRectList = svg.fitRect(\n      pathInfoList,\n      0,\n      0,\n      canvas.width,\n      canvas.height\n    )\n    inRectList.forEach((info) => {\n      geo.triangleSplit(info.d).forEach((points) => {\n        svg.draw(ctx, { d: points, style: info.style })\n      })\n    })\n  }\n}\n"]}